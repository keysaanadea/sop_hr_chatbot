<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DENAI - Natural Speech-to-Speech</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Manrope:wght@400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
/* SEMUA CSS TETAP SAMA - TIDAK DIUBAH */
* { 
  box-sizing: border-box; 
  margin: 0;
  padding: 0;
}

:root {
  --bg-primary: #0a0b0f;
  --bg-secondary: #12141a;
  --bg-tertiary: #1a1d26;
  --accent-primary: #00d4aa;
  --accent-secondary: #0891b2;
  --accent-gradient: linear-gradient(135deg, #00d4aa 0%, #00b4d4 50%, #0891b2 100%);
  --accent-danger: #f43f5e;
  --accent-speech: #8b5cf6;
  --accent-call: #10b981;
  --text-primary: #f8fafc;
  --text-secondary: #cbd5e1;
  --text-muted: #64748b;
  --border-primary: #1e293b;
  --border-secondary: #334155;
  --glow-primary: rgba(0, 212, 170, 0.4);
  --glow-secondary: rgba(0, 180, 212, 0.3);
  
  --font-display: 'Manrope', system-ui, sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
  --font-brand: 'Orbitron', 'JetBrains Mono', monospace;
  
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;
  
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
}

body {
  height: 100vh;
  font-family: var(--font-display);
  background: var(--bg-primary);
  color: var(--text-primary);
  display: flex;
  overflow: hidden;
  font-weight: 400;
  line-height: 1.5;
}

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border-secondary); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

/* ================= CALL MODE - TETAP SAMA ================= */
.call-mode-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(16, 185, 129, 0.2) 100%);
  backdrop-filter: blur(20px);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  animation: callFadeIn 0.5s ease;
}

.call-mode-overlay.active {
  display: flex;
}

@keyframes callFadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

.call-interface {
  text-align: center;
  max-width: 500px;
  padding: var(--space-2xl);
  background: rgba(26, 29, 38, 0.8);
  border-radius: var(--radius-xl);
  border: 1px solid var(--accent-call);
  box-shadow: 
    0 20px 60px rgba(16, 185, 129, 0.3),
    0 0 0 1px rgba(16, 185, 129, 0.2);
}

.call-avatar {
  width: 120px;
  height: 120px;
  margin: 0 auto var(--space-xl);
  background: var(--accent-gradient);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-brand);
  font-size: 48px;
  font-weight: 900;
  color: var(--bg-primary);
  position: relative;
  animation: callPulse 2s infinite ease-in-out;
}

@keyframes callPulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
  50% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(16, 185, 129, 0); }
}

.call-status {
  font-size: 24px;
  font-weight: 700;
  color: var(--accent-call);
  margin-bottom: var(--space-md);
  font-family: var(--font-brand);
}

.call-transcript {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  margin: var(--space-lg) 0;
  min-height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-style: italic;
  color: var(--text-secondary);
  border: 1px solid var(--border-primary);
}

.call-controls {
  display: flex;
  gap: var(--space-lg);
  justify-content: center;
  margin-top: var(--space-xl);
}

.call-control-btn {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  font-size: 24px;
}

.call-control-btn.end-call {
  background: var(--accent-danger);
  color: white;
}

.call-control-btn.end-call:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.call-control-btn.mute {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 2px solid var(--border-primary);
}

.call-control-btn.mute:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.call-control-btn.mute.active {
  background: var(--accent-danger);
  color: white;
}

/* ================= SPEECH CONTROLS - TETAP SAMA ================= */
.speech-controls {
  display: flex;
  gap: var(--space-sm);
  align-items: center;
  margin-left: auto;
}

.speech-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  padding: var(--space-md);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 48px;
  min-height: 48px;
  position: relative;
  overflow: hidden;
}

.speech-btn:hover {
  background: rgba(139, 92, 246, 0.1);
  border-color: var(--accent-speech);
  transform: scale(1.05);
}

.speech-btn.listening {
  background: linear-gradient(135deg, var(--accent-speech) 0%, #a855f7 100%);
  border-color: var(--accent-speech);
  animation: pulse 2s infinite;
}

.speech-btn.call-mode {
  background: linear-gradient(135deg, var(--accent-call) 0%, #059669 100%);
  border-color: var(--accent-call);
  animation: callGlow 2s infinite;
}

@keyframes callGlow {
  0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
  50% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
}

.speech-btn svg {
  width: 20px;
  height: 20px;
  color: var(--text-secondary);
  transition: color 0.3s ease;
}

.speech-btn:hover svg,
.speech-btn.listening svg,
.speech-btn.call-mode svg {
  color: var(--text-primary);
}

/* ================= AUDIO VISUALIZER - TETAP SAMA ================= */
.audio-visualizer {
  display: flex;
  gap: 3px;
  align-items: center;
  height: 30px;
  margin: var(--space-lg) 0;
}

.audio-bar {
  width: 4px;
  background: var(--accent-call);
  border-radius: 2px;
  transition: height 0.1s ease;
  min-height: 4px;
}

.audio-bar.active {
  animation: audioWave 1s ease-in-out infinite;
}

@keyframes audioWave {
  0%, 100% { height: 6px; }
  50% { height: 24px; }
}

/* ================= VOLUME INDICATOR - TETAP SAMA ================= */
.volume-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-lg);
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.8);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-lg);
  font-size: 12px;
  color: var(--accent-call);
  font-family: var(--font-mono);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.volume-indicator.show {
  opacity: 1;
}

/* ================= SIDEBAR - TETAP SAMA ================= */
.sidebar {
  width: 300px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border-primary);
  padding: var(--space-lg);
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
  position: relative;
}

.sidebar-header {
  display: flex;
  align-items: center;
  gap: var(--space-lg);
  padding: var(--space-xl);
  background: linear-gradient(135deg, rgba(26, 29, 38, 0.9) 0%, rgba(18, 20, 26, 0.95) 100%);
  border-radius: var(--radius-xl);
  border: 1px solid var(--border-primary);
  position: relative;
  overflow: hidden;
}

.sidebar-header .logo {
  width: 42px;
  height: 42px;
  background: var(--accent-gradient);
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-brand);
  font-weight: 800;
  font-size: 16px;
  color: var(--bg-primary);
  box-shadow: 
    0 4px 16px rgba(0, 212, 170, 0.4),
    0 8px 32px rgba(0, 180, 212, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
  position: relative;
  z-index: 1;
}

.sidebar-header .title {
  font-family: var(--font-brand);
  font-weight: 700;
  font-size: 18px;
  letter-spacing: 0.05em;
  color: var(--text-primary);
  text-transform: uppercase;
  background: var(--accent-gradient);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 8px var(--glow-primary));
  position: relative;
  z-index: 1;
}

.new-chat {
  background: var(--accent-gradient);
  border: none;
  padding: var(--space-lg) var(--space-2xl);
  border-radius: var(--radius-xl);
  color: var(--bg-primary);
  font-weight: 700;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 
    0 6px 20px rgba(0, 212, 170, 0.3),
    0 12px 40px rgba(0, 180, 212, 0.15);
  font-family: var(--font-display);
  position: relative;
  overflow: hidden;
  z-index: 1;
}

.new-chat:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: 
    0 8px 30px rgba(0, 212, 170, 0.5),
    0 16px 60px rgba(0, 180, 212, 0.25);
}

.new-chat svg {
  width: 18px;
  height: 18px;
}

.history {
  overflow-y: auto;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.session-item {
  padding: var(--space-md) var(--space-lg);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  background: var(--bg-tertiary);
  border: 1px solid transparent;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
  overflow: hidden;
}

.session-item:hover {
  background: rgba(45, 212, 191, 0.1);
  border-color: rgba(45, 212, 191, 0.3);
  transform: translateX(4px);
}

.session-item.active {
  background: rgba(45, 212, 191, 0.15);
  border-color: rgba(45, 212, 191, 0.4);
  font-weight: 600;
}

.session-item .title {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-size: 13px;
  color: var(--text-secondary);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
}

/* üî• NEW: Session Management Styles */
.session-item .pin-icon {
  font-size: 12px;
  color: var(--accent-primary);
  margin-right: 4px;
}

.session-actions {
  display: none;
  gap: 4px;
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-secondary);
  padding: 4px;
  border-radius: var(--radius-md);
  border: 1px solid var(--border-primary);
  z-index: 10;
}

.session-item:hover .session-actions {
  display: flex;
}

.session-action-btn {
  background: transparent;
  border: none;
  padding: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: all 0.2s ease;
}

.session-action-btn:hover {
  background: var(--bg-tertiary);
  transform: scale(1.1);
}

.session-action-btn svg {
  width: 14px;
  height: 14px;
  color: var(--text-muted);
}

.session-action-btn:hover svg {
  color: var(--text-primary);
}

.session-action-btn.pin-btn.active svg {
  color: var(--accent-primary);
  fill: var(--accent-primary);
}

.session-action-btn.delete-btn:hover svg {
  color: var(--accent-danger);
}
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--bg-primary);
}

.header {
  padding: var(--space-xl) var(--space-2xl);
  border-bottom: 1px solid var(--border-primary);
  background: var(--bg-secondary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}

#appTitle {
  font-size: 24px;
  font-weight: 800;
  letter-spacing: 0.02em;
  display: flex;
  align-items: center;
  gap: var(--space-lg);
  color: var(--text-primary);
  font-family: var(--font-brand);
  text-transform: uppercase;
  background: var(--accent-gradient);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 12px var(--glow-primary));
  position: relative;
}

#appTitle .logo-icon {
  width: 48px;
  height: 48px;
  background: var(--accent-gradient);
  border-radius: var(--radius-xl);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-brand);
  font-weight: 900;
  font-size: 20px;
  color: var(--bg-primary);
  box-shadow: 
    0 6px 20px rgba(0, 212, 170, 0.4),
    0 12px 40px rgba(0, 180, 212, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
  position: relative;
  z-index: 1;
}

.header-right {
  display: flex;
  gap: var(--space-lg);
  align-items: center;
}

.user-badge {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-lg);
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  border: 1px solid var(--border-primary);
  font-size: 12px;
  font-weight: 600;
  font-family: var(--font-mono);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.user-badge.hr {
  color: var(--accent-danger);
  border-color: rgba(244, 63, 94, 0.3);
  background: rgba(244, 63, 94, 0.1);
}

.user-badge .badge-icon {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent-primary);
  animation: pulse 2s infinite;
}

.user-badge.hr .badge-icon {
  background: var(--accent-danger);
}

#landing {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: var(--space-2xl);
  gap: var(--space-2xl);
  position: relative;
}

#landing h1 {
  font-size: 64px;
  font-weight: 900;
  color: var(--text-primary);
  text-align: center;
  letter-spacing: 0.05em;
  line-height: 0.9;
  font-family: var(--font-brand);
  text-transform: uppercase;
  background: var(--accent-gradient);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  position: relative;
  z-index: 1;
  filter: drop-shadow(0 0 20px var(--glow-primary));
  margin-bottom: var(--space-lg);
}

#landing .subtitle {
  font-size: 18px;
  color: var(--text-secondary);
  font-weight: 400;
  text-align: center;
  max-width: 600px;
  font-family: var(--font-display);
  line-height: 1.6;
  margin-top: var(--space-md);
}

.search-box {
  width: 100%;
  max-width: 600px;
  display: flex;
  align-items: center;
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: var(--radius-xl);
  padding: var(--space-sm);
  box-shadow: 
    0 8px 30px rgba(0, 0, 0, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  gap: var(--space-sm);
}

.search-box:focus-within {
  border-color: rgba(45, 212, 191, 0.5);
  box-shadow: 
    0 8px 30px rgba(0, 0, 0, 0.3),
    0 0 0 1px rgba(45, 212, 191, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.search-box input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 16px;
  padding: var(--space-lg) var(--space-xl);
  font-family: var(--font-display);
  font-weight: 500;
}

.search-box input::placeholder {
  color: var(--text-muted);
}

.search-box .speech-btn {
  background: transparent;
  border: none;
  padding: var(--space-md);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 44px;
  min-height: 44px;
  margin: 0;
}

.search-box .speech-btn:hover {
  background: rgba(139, 92, 246, 0.1);
  transform: scale(1.05);
}

.search-box .speech-btn.listening {
  background: rgba(139, 92, 246, 0.2);
  color: var(--accent-speech);
}

.search-box button {
  background: var(--accent-gradient);
  border: none;
  color: var(--bg-primary);
  padding: var(--space-lg) var(--space-2xl);
  border-radius: var(--radius-xl);
  cursor: pointer;
  font-weight: 700;
  font-size: 15px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  font-family: var(--font-display);
  box-shadow: 
    0 4px 16px rgba(0, 212, 170, 0.3),
    0 8px 32px rgba(0, 180, 212, 0.15);
  position: relative;
  overflow: hidden;
  z-index: 1;
}

.search-box button:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 24px rgba(0, 212, 170, 0.4),
    0 12px 48px rgba(0, 180, 212, 0.2);
}

#chat {
  display: none;
  flex: 1;
  flex-direction: column;
  overflow: hidden;
}

.messages {
  flex: 1;
  padding: var(--space-xl) var(--space-2xl);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.msg {
  display: flex;
  gap: var(--space-md);
  max-width: 75%;
  animation: slideInMessage 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

@keyframes slideInMessage {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.user-msg {
  margin-left: auto;
  flex-direction: row-reverse;
}

.avatar {
  width: 40px;
  height: 40px;
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 700;
  font-family: var(--font-mono);
  flex-shrink: 0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  color: var(--bg-primary);
  letter-spacing: 0.05em;
}

.user .avatar {
  background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
}

.bot .avatar {
  background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--border-secondary) 100%);
  color: var(--accent-primary);
}

.bubble {
  padding: var(--space-lg) var(--space-xl);
  border-radius: var(--radius-xl);
  line-height: 1.6;
  word-break: break-word;
  overflow-wrap: anywhere;
  font-size: 14px;
  font-weight: 500;
  position: relative;
}

.user .bubble {
  background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
  color: var(--bg-primary);
  border-bottom-right-radius: var(--radius-sm);
  white-space: pre-wrap;
  font-weight: 600;
}

.bot .bubble {
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  color: var(--text-secondary);
  border-bottom-left-radius: var(--radius-sm);
}

.message-actions {
  position: absolute;
  top: -12px;
  right: 12px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--radius-lg);
  padding: 4px;
  display: none;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
  backdrop-filter: blur(10px);
}

.msg:hover .message-actions {
  display: flex;
  opacity: 1;
}

.action-btn {
  background: transparent;
  border: none;
  padding: 6px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-muted);
}

.action-btn:hover {
  background: var(--accent-speech);
  color: var(--text-primary);
  transform: scale(1.1);
}

.action-btn svg {
  width: 16px;
  height: 16px;
}

/* üî• HTML FORMAT DISPLAY - TETAP BAGUS! */
.bubble h3 {
  margin: 16px 0 10px 0;
  font-size: 18px;
  font-weight: 800;
  color: var(--accent-primary);
  line-height: 1.3;
  letter-spacing: -0.02em;
  text-transform: none;
}

.bubble h3:first-child {
  margin-top: 0;
}

.bubble p {
  margin: 0 0 12px 0;
  line-height: 1.6;
}

.bubble p:last-child {
  margin-bottom: 0;
}

.bubble ul,
.bubble ol {
  margin: 8px 0 12px 0;
  padding-left: 20px;
  list-style-position: outside;
}

.bubble li {
  margin-bottom: 8px;
  line-height: 1.5;
}

.bubble li:last-child {
  margin-bottom: 0;
}

.bubble strong,
.bubble b {
  color: var(--text-primary);
  font-weight: 700;
}

.bubble em,
.bubble i {
  color: var(--text-muted);
  font-style: italic;
}

.input-box {
  padding: var(--space-xl) var(--space-2xl);
  display: flex;
  gap: var(--space-md);
  border-top: 1px solid var(--border-primary);
  background: var(--bg-secondary);
  position: relative;
  align-items: center;
}

.input-container {
  flex: 1;
  display: flex;
  align-items: center;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--radius-lg);
  padding: var(--space-sm);
  transition: all 0.3s ease;
}

.input-container:focus-within {
  border-color: rgba(45, 212, 191, 0.5);
  background: var(--bg-primary);
  box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.2);
}

.input-container input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 14px;
  font-family: var(--font-display);
  font-weight: 500;
  padding: var(--space-md) var(--space-lg);
}

.input-container input::placeholder {
  color: var(--text-muted);
}

.input-container input:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.input-container .speech-btn {
  background: transparent;
  border: none;
  padding: var(--space-sm);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 36px;
  min-height: 36px;
  margin: 0;
}

.input-container .speech-btn:hover {
  background: rgba(139, 92, 246, 0.1);
  transform: scale(1.05);
}

.input-container .speech-btn.listening {
  background: rgba(139, 92, 246, 0.2);
  color: var(--accent-speech);
}

.input-container .speech-btn svg {
  width: 18px;
  height: 18px;
  color: var(--text-muted);
  transition: color 0.3s ease;
}

.input-container .speech-btn:hover svg,
.input-container .speech-btn.listening svg {
  color: var(--accent-speech);
}

.input-box button {
  background: var(--accent-gradient);
  border: none;
  padding: var(--space-lg) var(--space-2xl);
  border-radius: var(--radius-xl);
  color: var(--bg-primary);
  cursor: pointer;
  font-weight: 700;
  font-size: 14px;
  font-family: var(--font-display);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 
    0 4px 16px rgba(0, 212, 170, 0.3),
    0 8px 32px rgba(0, 180, 212, 0.15);
  position: relative;
  overflow: hidden;
  z-index: 1;
}

.input-box button:hover:not(:disabled) {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 24px rgba(0, 212, 170, 0.4),
    0 12px 48px rgba(0, 180, 212, 0.2);
}

.input-box button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.loading-indicator {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 2px solid var(--border-primary);
  border-radius: 50%;
  border-top-color: var(--accent-primary);
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* ================= RESPONSIVE ================= */
@media (max-width: 768px) {
  .sidebar { width: 260px; }
  #landing h1 { font-size: 36px; }
  .search-box { max-width: 95%; }
  .msg { max-width: 90%; }
  .messages { padding: var(--space-lg); }
  .input-box { padding: var(--space-lg); }
}

@media (max-width: 640px) {
  .sidebar { display: none; }
  .header { padding: var(--space-lg); }
  #appTitle { font-size: 18px; }
  #landing h1 { font-size: 28px; }
  .search-box input { font-size: 14px; }
}
</style>
</head>

<body>

<!-- Call Mode Overlay - TETAP SAMA -->
<div class="call-mode-overlay" id="callModeOverlay">
  <div class="call-interface">
    <div class="call-avatar">AI</div>
    <div class="call-status" id="callStatus">üîä Call Mode Active</div>
    <div class="call-transcript" id="callTranscript">
      Bicara sekarang... DENAI sedang mendengarkan
    </div>
    
    <!-- Audio Visualizer -->
    <div class="audio-visualizer" id="audioVisualizer">
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
    </div>
    
    <div class="call-controls">
      <button class="call-control-btn mute" id="muteBtn" title="Mute">üé§</button>
      <button class="call-control-btn end-call" id="endCallBtn" title="End Call">üìû</button>
    </div>
  </div>
</div>

<!-- Volume Indicator -->
<div class="volume-indicator" id="volumeIndicator">
  üîä Volume: <span id="volumeLevel">100</span>%
</div>

<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <div class="logo">DN</div>
    <span class="title">DENAI</span>
  </div>
  
  <button class="new-chat" onclick="newChat()">
    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
    </svg>
    <span>New Conversation</span>
  </button>
  
  <div class="history" id="sessionList"></div>
</div>

<div class="main">
  <div class="header">
    <span id="appTitle">
      <div class="logo-icon">DN</div>
      <span>DENAI</span>
    </span>
    
    <div class="header-right">
      <div class="speech-controls">
        <!-- Real-time Call Mode Button -->
        <button class="speech-btn" id="callModeBtn" title="Real-time Call Mode">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
          </svg>
        </button>
      </div>
      
      <div class="user-badge" id="userBadge">
        <div class="badge-icon"></div>
        <span id="userRole">Loading...</span>
      </div>
    </div>
  </div>

  <div id="landing">
    <h1>DENAI</h1>
    <p class="subtitle">Ask anything about procedures, policies, or company data. Now with natural speech!</p>
    <div class="search-box">
      <input id="landingInput" placeholder="Type or speak your question..." />
      <button class="speech-btn" id="landingSpeechBtn" title="Voice Input">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
        </svg>
      </button>
      <button onclick="startFromLanding()">Submit</button>
    </div>
  </div>

  <div id="chat">
    <div class="messages" id="messages"></div>
    <div class="input-box">
      <div class="input-container">
        <input id="chatInput" placeholder="Type or speak your question..." />
        <button class="speech-btn" id="chatSpeechBtn" title="Voice Input">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
          </svg>
        </button>
      </div>
      <button id="sendButton" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
/* ================= GLOBAL STATE ================= */
let activeChatId = null;
let isWaitingForResponse = false;
let conversationHistory = [];
let userRole = null;
let isHR = false;

// Speech system state
let speechRecognition = null;
let isListening = false;
let currentSpeechButton = null;
let currentInput = null;
let isSpeaking = false;

// Real-time call mode state
let isCallModeActive = false;
let continuousListening = false;
let callSession = null;
let isProcessingCall = false;
let currentAudio = null;
let processingAudio = null;

/* ================= üî• AUDIO FEEDBACK SYSTEM ================= */
async function playProcessingFeedback() {
  try {
    console.log('üîä Playing processing feedback...');
    
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance("Please wait, processing your request.");
      utterance.lang = 'en-US';
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 0.8;
      
      utterance.onstart = () => console.log('üîä Processing feedback started');
      utterance.onend = () => console.log('üîä Processing feedback ended');
      
      window.speechSynthesis.speak(utterance);
      processingAudio = utterance;
    }
  } catch (error) {
    console.error('üîä Failed to play processing feedback:', error);
  }
}

function stopProcessingFeedback() {
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
  processingAudio = null;
}

/* ================= DOM CACHE ================= */
const landing = document.getElementById("landing");
const chat = document.getElementById("chat");
const messages = document.getElementById("messages");
const chatInput = document.getElementById("chatInput");
const landingInput = document.getElementById("landingInput");
const sendButton = document.getElementById("sendButton");
const userBadge = document.getElementById("userBadge");
const userRoleText = document.getElementById("userRole");

// Call mode elements
const callModeOverlay = document.getElementById("callModeOverlay");
const callStatus = document.getElementById("callStatus");
const callTranscript = document.getElementById("callTranscript");
const callModeBtn = document.getElementById("callModeBtn");
const endCallBtn = document.getElementById("endCallBtn");
const muteBtn = document.getElementById("muteBtn");
const audioVisualizer = document.getElementById("audioVisualizer");
const volumeIndicator = document.getElementById("volumeIndicator");

// Speech buttons
const landingSpeechBtn = document.getElementById("landingSpeechBtn");
const chatSpeechBtn = document.getElementById("chatSpeechBtn");

/* ================= SPEECH RECOGNITION SYSTEM ================= */
function initializeSpeechRecognition() {
  if ('webkitSpeechRecognition' in window) {
    speechRecognition = new webkitSpeechRecognition();
  } else if ('SpeechRecognition' in window) {
    speechRecognition = new SpeechRecognition();
  } else {
    console.warn('Speech recognition not supported');
    document.querySelectorAll('.speech-btn').forEach(btn => {
      btn.style.display = 'none';
    });
    return false;
  }

  speechRecognition.continuous = true;
  speechRecognition.interimResults = true;
  speechRecognition.lang = 'id-ID';
  speechRecognition.maxAlternatives = 1;

  speechRecognition.onstart = function() {
    console.log('[STT] ‚úÖ Speech recognition STARTED');
    isListening = true;
    updateSpeechUI(true);
    
    if (isCallModeActive) {
      callStatus.textContent = 'üé§ Listening...';
      showAudioVisualization(true);
    }
  };

  speechRecognition.onresult = function(event) {
    console.log('[STT] Results received, processing...');
    let interimTranscript = '';
    let finalTranscript = '';

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript;
      
      if (event.results[i].isFinal) {
        finalTranscript += transcript;
      } else {
        interimTranscript += transcript;
      }
    }

    const displayText = finalTranscript || interimTranscript;
    
    // Update UI based on mode
    if (isCallModeActive) {
      callTranscript.textContent = displayText || 'Listening...';
    }
    
    if (currentInput && displayText) {
      currentInput.value = displayText;
    }

    // Handle final transcript
    if (finalTranscript) {
      console.log('[STT] ‚úÖ Final transcript received:', finalTranscript);
      
      if (isCallModeActive) {
        // Real-time call mode - process immediately
        handleCallModeInput(finalTranscript.trim());
      } else if (currentInput) {
        // Regular mode - auto-submit
        currentInput.value = finalTranscript.trim();
        setTimeout(() => {
          if (currentInput === landingInput) {
            startFromLanding();
          } else {
            sendMessage();
          }
        }, 500);
      }
    }
  };

  speechRecognition.onerror = function(event) {
    console.error('[STT] ‚ùå Speech recognition error:', event.error);
    
    if (event.error === 'not-allowed') {
      alert('Microphone access is required. Please allow microphone access and try again.');
    } else if (event.error === 'no-speech') {
      if (isCallModeActive && continuousListening) {
        // Restart listening in call mode
        setTimeout(() => restartCallListening(), 1000);
      }
    }
  };

  speechRecognition.onend = function() {
    console.log('[STT] Speech recognition ended');
    isListening = false;
    updateSpeechUI(false);
    
    if (isCallModeActive) {
      showAudioVisualization(false);
      if (continuousListening && !isProcessingCall) {
        // Restart listening in call mode
        setTimeout(() => restartCallListening(), 500);
      }
    }
  };

  return true;
}

/* ================= üî• ENHANCED NATURAL TTS SYSTEM ================= */
async function speakText(text, options = {}) {
  console.log('üîä speakText called with:', text ? text.substring(0, 50) : 'null/empty');
  
  if (!text || text.trim().length === 0) {
    console.error('üîä No text provided to speak');
    return null;
  }

  console.log('üîä Calling NATURAL TTS API');

  try {
    // Stop any currently playing audio
    if (currentAudio) {
      currentAudio.pause();
      currentAudio = null;
    }

    // Show volume indicator
    showVolumeIndicator();

    // üî• CALL NATURAL TTS API - HTML akan di-clean di backend!
    const requestPayload = {
      text: text,  // Kirim HTML asli, backend yang clean
      language: options.language || 'id',
      voice: options.voice || 'indonesian',
      slow: options.slow || false
    };
    
    console.log('üîä Natural TTS Request');
    
    // Call Natural TTS API
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
      console.error('üîä ‚ùå TTS request timeout (15s)');
    }, 15000);

    const response = await fetch('http://127.0.0.1:8000/speech/text-to-speech', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestPayload),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('üîä TTS API failed:', response.status, errorText);
      throw new Error(`TTS API failed: ${response.status}`);
    }

    // Get audio blob
    const audioBlob = await response.blob();
    console.log('üîä ‚úÖ Received natural audio blob:', audioBlob.size, 'bytes');

    if (audioBlob.size === 0) {
      throw new Error('Received empty audio blob');
    }

    // Create and play audio
    const audioUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(audioUrl);
    currentAudio = audio;
    
    audio.volume = 0.9;
    audio.preload = 'auto';
    
    return new Promise((resolve, reject) => {
      audio.onloadeddata = () => {
        console.log('üîä ‚úÖ Natural audio loaded, duration:', audio.duration, 'seconds');
      };
      
      audio.onplay = () => {
        console.log('üîä ‚úÖ Natural speech playback STARTED');
        isSpeaking = true;
        
        if (isCallModeActive) {
          callStatus.textContent = 'üîä DENAI Speaking...';
        }
      };

      audio.onended = () => {
        console.log('üîä ‚úÖ Natural speech playback ENDED');
        isSpeaking = false;
        URL.revokeObjectURL(audioUrl);
        currentAudio = null;
        hideVolumeIndicator();
        
        if (isCallModeActive && !isProcessingCall) {
          // Resume listening in call mode after TTS completes
          setTimeout(() => {
            if (isCallModeActive && continuousListening) {
              callStatus.textContent = 'üé§ Listening...';
              callTranscript.textContent = 'Bicara lagi...';
              restartCallListening();
            }
          }, 500);
        }
        
        resolve(audio);
      };

      audio.onerror = (error) => {
        console.error('üîä ‚ùå Audio playback error:', error);
        isSpeaking = false;
        URL.revokeObjectURL(audioUrl);
        currentAudio = null;
        hideVolumeIndicator();
        reject(error);
      };

      // Start playback
      audio.play().catch(playError => {
        console.error('üîä ‚ùå Audio.play() failed:', playError);
        
        if (playError.name === 'NotAllowedError') {
          const userConfirm = confirm('Audio is blocked by browser. Click OK to enable audio playback.');
          if (userConfirm) {
            audio.play().then(() => resolve(audio)).catch(reject);
          } else {
            reject(playError);
          }
        } else {
          reject(playError);
        }
      });
    });
    
  } catch (error) {
    console.error('üîä ‚ùå Natural TTS error:', error);
    hideVolumeIndicator();
    
    if (error.name === 'AbortError') {
      console.error('üîä TTS request was aborted (timeout)');
      return null;
    }
    
    // Fallback to browser TTS
    console.log('üîä Attempting browser TTS fallback...');
    return speakTextFallback(text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim());
  }
}

function speakTextFallback(text) {
  try {
    if (!window.speechSynthesis) {
      console.error('üîä Browser TTS not available');
      return null;
    }

    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'id-ID';
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 0.9;

    utterance.onstart = () => {
      isSpeaking = true;
      console.log('üîä Browser TTS fallback started');
      showVolumeIndicator();
    };

    utterance.onend = () => {
      isSpeaking = false;
      console.log('üîä Browser TTS fallback ended');
      hideVolumeIndicator();
    };

    utterance.onerror = (error) => {
      console.error('üîä Browser TTS error:', error.error);
      isSpeaking = false;
      hideVolumeIndicator();
    };

    window.speechSynthesis.speak(utterance);
    return utterance;
    
  } catch (error) {
    console.error('üîä Fallback TTS failed:', error);
    return null;
  }
}

function stopTextToSpeech() {
  // Stop server TTS
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  // Stop browser TTS
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
  
  isSpeaking = false;
  hideVolumeIndicator();
  console.log('üîä All speech stopped');
}

function showVolumeIndicator() {
  volumeIndicator.classList.add('show');
  setTimeout(() => {
    volumeIndicator.classList.remove('show');
  }, 3000);
}

function hideVolumeIndicator() {
  volumeIndicator.classList.remove('show');
}

/* ================= CALL MODE SYSTEM ================= */
async function startCallMode() {
  if (isCallModeActive) {
    endCallMode();
    return;
  }

  if (!speechRecognition) {
    alert('Speech recognition is not supported in your browser.');
    return;
  }

  try {
    // Request microphone permission
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop());
    
    // Initialize call mode
    isCallModeActive = true;
    continuousListening = true;
    isProcessingCall = false;
    callSession = activeChatId || crypto.randomUUID();
    
    // Update UI
    callModeOverlay.classList.add('active');
    callModeBtn.classList.add('call-mode');
    callStatus.textContent = 'üìû Call Connected';
    callTranscript.textContent = 'Bicara sekarang... DENAI sedang mendengarkan';
    
    // Hide main interface
    if (landing.style.display !== 'none') {
      landing.style.display = 'none';
      chat.style.display = 'flex';
      if (!activeChatId) {
        newChat();
      }
    }
    
    // Start continuous listening
    restartCallListening();
    
    console.log('üî• CALL MODE: Activated - Natural speech-to-speech ready!');
    
  } catch (error) {
    console.error('Failed to start call mode:', error);
    alert('Failed to access microphone. Please allow microphone access and try again.');
  }
}

function endCallMode() {
  isCallModeActive = false;
  continuousListening = false;
  isProcessingCall = false;
  
  // Stop speech recognition
  if (speechRecognition && isListening) {
    speechRecognition.stop();
  }
  
  // Stop any playing audio
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  // Update UI
  callModeOverlay.classList.remove('active');
  callModeBtn.classList.remove('call-mode');
  showAudioVisualization(false);
  
  console.log('üìû CALL MODE: Ended');
}

function restartCallListening() {
  if (!isCallModeActive || !continuousListening || isProcessingCall) {
    return;
  }

  try {
    if (speechRecognition) {
      speechRecognition.start();
      console.log('[CALL] Restarting continuous listening...');
    }
  } catch (error) {
    console.error('[CALL] Failed to restart listening:', error);
    setTimeout(() => restartCallListening(), 2000);
  }
}

async function handleCallModeInput(transcript) {
  if (!transcript || isProcessingCall) {
    return;
  }

  isProcessingCall = true;
  callStatus.textContent = 'ü§ñ Processing...';
  callTranscript.textContent = `You: ${transcript}`;
  
  // Stop listening temporarily (STT SELESAI - microphone FREE!)
  if (speechRecognition && isListening) {
    speechRecognition.stop();
  }
  
  // üî• NOW SAFE to play audio feedback - STT is done!
  // Wait a tiny bit to ensure STT fully stopped
  await new Promise(resolve => setTimeout(resolve, 300));
  
  try {
    // üî• Play audio feedback in Call Mode
    playProcessingFeedback();
    
    // Add user message to chat
    addMessage("user", transcript);
    
    // Get AI response (this will auto-stop processing feedback)
    await askBackend(transcript);
    
    // Wait a bit for TTS to complete before restarting listening
    setTimeout(() => {
      if (isCallModeActive && continuousListening) {
        isProcessingCall = false;
        callStatus.textContent = 'üé§ Listening...';
        callTranscript.textContent = 'Bicara lagi...';
        restartCallListening();
      }
    }, 2000);
    
  } catch (error) {
    console.error('[CALL] Error processing input:', error);
    stopProcessingFeedback(); // üî• Stop on error
    isProcessingCall = false;
    if (isCallModeActive) {
      restartCallListening();
    }
  }
}

function toggleMute() {
  const isMuted = muteBtn.classList.contains('active');
  
  if (isMuted) {
    // Unmute
    muteBtn.classList.remove('active');
    muteBtn.textContent = 'üé§';
    continuousListening = true;
    if (isCallModeActive && !isProcessingCall) {
      restartCallListening();
    }
  } else {
    // Mute
    muteBtn.classList.add('active');
    muteBtn.textContent = 'üîá';
    continuousListening = false;
    if (speechRecognition && isListening) {
      speechRecognition.stop();
    }
  }
}

function showAudioVisualization(show) {
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  
  if (show) {
    bars.forEach((bar, index) => {
      bar.classList.add('active');
      bar.style.animationDelay = `${index * 0.1}s`;
    });
  } else {
    bars.forEach(bar => {
      bar.classList.remove('active');
    });
  }
}

/* ================= REGULAR SPEECH RECOGNITION ================= */
async function startSpeechRecognition(button, input) {
  if (!speechRecognition) {
    alert('Speech recognition is not supported in your browser.');
    return;
  }

  if (isListening) {
    console.log('[STT] Stopping current listening session');
    speechRecognition.stop();
    return;
  }

  try {
    // Request microphone permission
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop());
    
  } catch (permissionError) {
    console.error('[STT] ‚ùå Microphone permission denied:', permissionError);
    alert('Microphone access is required for speech recognition.');
    return;
  }

  // Stop any playing audio
  if (isSpeaking) {
    stopTextToSpeech();
  }

  currentSpeechButton = button;
  currentInput = input;
  
  // Configure for single-shot recognition
  speechRecognition.continuous = false;
  speechRecognition.interimResults = true;

  try {
    speechRecognition.start();
  } catch (error) {
    console.error('[STT] ‚ùå Failed to start speech recognition:', error);
  }
}

function updateSpeechUI(isActive) {
  if (!isCallModeActive) {
    document.querySelectorAll('.speech-btn').forEach(btn => {
      if (isActive && btn === currentSpeechButton) {
        btn.classList.add('listening');
      } else if (!isActive) {
        btn.classList.remove('listening');
      }
    });
  }
}

/* ================= USER ROLE & SESSION MANAGEMENT ================= */
async function getUserRole() {
  try {
    const response = await fetch('http://127.0.0.1:8000/user/role', {
      headers: { "Accept": "application/json" }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    userRole = data.role || "Employee";
    isHR = data.is_hr || false;
    
    updateUserInterface();
    
  } catch (error) {
    console.error('Failed to get user role:', error);
    userRole = 'Employee';
    isHR = false;
    updateUserInterface();
  }
}

function updateUserInterface() {
  if (isHR) {
    userBadge.classList.add("hr");
    userRoleText.textContent = "HR Access";
  } else {
    userBadge.classList.remove("hr");
    userRoleText.textContent = "Employee";
  }
  
  loadSessions();
}

/* ================= CHAT FUNCTIONS ================= */
function newChat() {
  activeChatId = crypto.randomUUID();
  conversationHistory = [];
  messages.innerHTML = "";
  landing.style.display = "none";
  chat.style.display = "flex";
  
  if (!isCallModeActive) {
    chatInput.focus();
  }
}

function startFromLanding() {
  const text = landingInput.value.trim();
  if (!text || isWaitingForResponse) return;
  
  setInputState(true);
  newChat();
  addMessage("user", text);
  askBackend(text);
  landingInput.value = "";
  setInputState(false);
}

function addMessage(role, text, shouldSave = true) {
  const div = document.createElement("div");
  div.className = `msg ${role==="user"?"user-msg user":"bot"}`;
  
  const avatarText = role === "user" ? "YOU" : "AI";
  
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  
  if (role === "user") {
    bubble.textContent = text;
  } else {
    // üî• TAMPILKAN HTML DENGAN FORMAT BAGUS (TIDAK BERUBAH!)
    bubble.innerHTML = text;
  }
  
  div.innerHTML = `<div class="avatar">${avatarText}</div>`;
  div.appendChild(bubble);
  
  if (role === "bot") {
    const actions = document.createElement("div");
    actions.className = "message-actions";
    actions.innerHTML = `
      <button class="action-btn" onclick="speakMessage(this)" title="Read aloud">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M8.364 18.364L7 17l6-6-6-6 1.364-1.364L14.727 10l-6.363 6.364z"></path>
        </svg>
      </button>
      <button class="action-btn" onclick="stopTextToSpeech()" title="Stop speaking">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    `;
    div.appendChild(actions);
  }
  
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  
  if (shouldSave) {
    const textForHistory = role === "user" ? text : stripHtml(text);
    conversationHistory.push({
      role: role,
      message: textForHistory,
      timestamp: new Date().toISOString()
    });
  }
  
  return div;
}

function speakMessage(button) {
  const bubble = button.closest('.msg').querySelector('.bubble');
  if (bubble) {
    // üî• AMBIL FULL HTML - Backend yang akan clean untuk TTS!
    const htmlText = bubble.innerHTML;
    speakText(htmlText);
  }
}

function stripHtml(html) {
  const tmp = document.createElement("div");
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || "";
}

function setInputState(disabled) {
  if (!isCallModeActive) {
    chatInput.disabled = disabled;
    sendButton.disabled = disabled;
    landingInput.disabled = disabled;
    
    document.querySelectorAll('.speech-btn').forEach(btn => {
      btn.disabled = disabled;
    });
    
    if (disabled) {
      sendButton.innerHTML = '<div class="loading-indicator"></div>';
    } else {
      sendButton.innerHTML = 'Send';
    }
  }
  
  isWaitingForResponse = disabled;
}

/* ================= BACKEND COMMUNICATION ================= */
async function askBackend(text) {
  if (isWaitingForResponse && !isCallModeActive) return;
  
  setInputState(true);


  let loadingMessage = null;
  // üî• Play processing feedback
  if (!isCallModeActive) {
    playProcessingFeedback();
  }
  
  const payload = {
    question: text,
    session_id: activeChatId,
    user_role: userRole || "Employee"
  };

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 45000);

    const res = await fetch("http://127.0.0.1:8000/ask", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(payload),
      signal: controller.signal
    });

    clearTimeout(timeoutId);
    // üî• Stop processing feedback
    stopProcessingFeedback();

    if (res.status === 429) {
      if (loadingMessage && loadingMessage.parentNode) {
        loadingMessage.remove();
      }
      addMessage("bot", "‚è∞ <b>Rate Limit Exceeded</b><br><br>Too many requests. Please wait a moment.");
      return;
    }

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();
    
    if (loadingMessage && loadingMessage.parentNode) {
      loadingMessage.remove();
    }
    
    let responseText = "";
    
    if (data.error) {
      responseText = `‚ùå <b>Error</b><br><br>${data.error}`;
    } else if (data.authorized === false) {
      responseText = `üîí <b>Access Denied</b><br><br>${data.answer}`;
    } else if (data.answer) {
      // üî• RESPONSE TETAP HTML FORMAT (TIDAK BERUBAH!)
      responseText = data.answer;
    } else {
      responseText = "‚ùì Received unexpected response format from server.";
    }
    
    const messageElement = addMessage("bot", responseText);
    
    // üî• Auto-speak dengan NATURAL TTS (backend akan clean HTML)
    setTimeout(() => {
      speakText(responseText, {  // Kirim HTML asli
        language: 'id',
        voice: 'indonesian'
      });
    }, isCallModeActive ? 200 : 800);
    
  } catch (err) {
    // üî• Stop processing feedback
    stopProcessingFeedback();
    if (loadingMessage && loadingMessage.parentNode) {
      loadingMessage.remove();
    }
    
    let errorMessage = "‚ùå Failed to connect to server.";
    
    if (err.name === 'AbortError') {
      errorMessage = "‚è∞ Request timed out. Please try again.";
    }
    
    addMessage("bot", errorMessage);
    
    if (isCallModeActive) {
      setTimeout(() => {
        speakText(stripHtml(errorMessage));
      }, 500);
    }
    
  } finally {
    setInputState(false);
    if (!isCallModeActive && chatInput) {
      chatInput.focus();
    }
    
    try {
      await loadSessions();
    } catch (sessionError) {
      console.error("Session update failed:", sessionError);
    }
  }
}
/* ================= üî• SESSION MANAGEMENT - PIN & DELETE ================= */
async function togglePinSession(sessionId, event) {
  event.stopPropagation();
  
  try {
    const response = await fetch(`http://127.0.0.1:8000/sessions/${sessionId}/pin`, {
      method: 'POST',
      headers: { 'Accept': 'application/json' }
    });
    
    if (response.ok) {
      await loadSessions();
    }
  } catch (error) {
    console.error('Failed to pin session:', error);
  }
}

async function deleteSession(sessionId, event) {
  event.stopPropagation();
  
  const confirmed = confirm('Are you sure you want to delete this conversation?');
  if (!confirmed) return;
  
  try {
    const response = await fetch(`http://127.0.0.1:8000/sessions/${sessionId}`, {
      method: 'DELETE',
      headers: { 'Accept': 'application/json' }
    });
    
    if (response.ok) {
      // If deleting active session, return to landing
      if (sessionId === activeChatId) {
        activeChatId = null;
        conversationHistory = [];
        messages.innerHTML = "";
        landing.style.display = "flex";
        chat.style.display = "none";
      }
      
      await loadSessions();
    }
  } catch (error) {
    console.error('Failed to delete session:', error);
    alert('Failed to delete conversation. Please try again.');
  }
}
/* ================= SESSION MANAGEMENT ================= */
async function loadSessions() {
  try {
    const res = await fetch("http://127.0.0.1:8000/sessions", {
      headers: { "Accept": "application/json" }
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    
    const sessions = await res.json();
    const list = document.getElementById("sessionList");
    list.innerHTML = "";
    
    let filteredSessions = sessions;
    
    if (!isHR) {
      filteredSessions = sessions.filter(s => {
        const title = (s.title || '').toLowerCase();
        const hrKeywords = [
          'karyawan', 'band', 'employee', 'gaji', 
          'kontrak', 'salary', 'upah', 'pegawai', 
          'staff', 'sdm', 'personalia', 'jumlah'
        ];
        const isHRConversation = hrKeywords.some(keyword => title.includes(keyword));
        return !isHRConversation;
      });
    }
    
    // Sessions already sorted by backend (pinned first, then by date)

    filteredSessions.forEach((s) => {
      const div = document.createElement("div");
      div.className = "session-item";
      if (s.session_id === activeChatId) div.classList.add("active");

      const isPinned = s.pinned || false;
      const pinIcon = isPinned ? '<span class="pin-icon">üìå</span>' : '';
      
      div.innerHTML = `
        <span class="title">
          ${pinIcon}
          ${s.title || 'Untitled Conversation'}
        </span>
        <div class="session-actions">
          <button class="session-action-btn pin-btn ${isPinned ? 'active' : ''}" 
                  onclick="togglePinSession('${s.session_id}', event)" 
                  title="${isPinned ? 'Unpin' : 'Pin'}">
            <svg fill="${isPinned ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                    d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path>
            </svg>
          </button>
          <button class="session-action-btn delete-btn" 
                  onclick="deleteSession('${s.session_id}', event)" 
                  title="Delete">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
          </button>
        </div>
      `;

      div.onclick = (e) => {
        // Don't load session if clicking on action buttons
        if (e.target.closest('.session-actions')) return;
        loadSession(s.session_id);
      };
      
      list.appendChild(div);
    });
    
  } catch (err) {
    console.error("Failed to load sessions:", err);
  }
}

async function loadSession(sessionId) {
  if (isWaitingForResponse) return;
  
  try {
    activeChatId = sessionId;
    conversationHistory = [];

    messages.innerHTML = "";
    landing.style.display = "none";
    chat.style.display = "flex";

    const res = await fetch(`http://127.0.0.1:8000/history/${sessionId}`, {
      headers: { "Accept": "application/json" }
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    
    const history = await res.json();

    history.forEach(m => {
      addMessage(m.role, m.message, false);
      
      const textForHistory = m.role === "user" ? m.message : stripHtml(m.message);
      conversationHistory.push({
        role: m.role,
        message: textForHistory,
        timestamp: m.timestamp || new Date().toISOString()
      });
    });

    await loadSessions();
    if (!isCallModeActive) {
      chatInput.focus();
    }
    
  } catch (err) {
    console.error("Failed to load session:", err);
    addMessage("bot", "‚ùå Failed to load conversation.");
  }
}

function sendMessage() {
  const text = chatInput.value.trim();
  if (!text || isWaitingForResponse) return;

  addMessage("user", text);
  askBackend(text);
  chatInput.value = "";
}

/* ================= EVENT LISTENERS ================= */

// Call mode controls
callModeBtn.addEventListener("click", startCallMode);
endCallBtn.addEventListener("click", endCallMode);
muteBtn.addEventListener("click", toggleMute);

// Regular input events
chatInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !isWaitingForResponse && !e.shiftKey && !isCallModeActive) {
    e.preventDefault();
    sendMessage();
  }
});

landingInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !isWaitingForResponse && !e.shiftKey && !isCallModeActive) {
    e.preventDefault();
    startFromLanding();
  }
});

// Speech buttons
landingSpeechBtn.addEventListener("click", () => {
  if (!isCallModeActive) {
    startSpeechRecognition(landingSpeechBtn, landingInput);
  }
});

chatSpeechBtn.addEventListener("click", () => {
  if (!isCallModeActive) {
    startSpeechRecognition(chatSpeechBtn, chatInput);
  }
});

// Stop typing when speaking
chatInput.addEventListener("input", () => {
  if (isListening && !isCallModeActive) {
    speechRecognition.stop();
  }
});

landingInput.addEventListener("input", () => {
  if (isListening && !isCallModeActive) {
    speechRecognition.stop();
  }
});

// Global keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Escape to end call mode
  if (e.key === 'Escape' && isCallModeActive) {
    endCallMode();
  }
  
  // Ctrl/Cmd + / to toggle call mode
  if ((e.ctrlKey || e.metaKey) && e.key === '/') {
    e.preventDefault();
    if (isCallModeActive) {
      endCallMode();
    } else {
      startCallMode();
    }
  }
});

/* ================= INITIALIZATION ================= */
document.addEventListener("DOMContentLoaded", async () => {
  const speechAvailable = initializeSpeechRecognition();
  await getUserRole();
  
  if (!isCallModeActive) {
    landingInput.focus();
  }
  
  console.log("üéôÔ∏è DENAI Natural Speech-to-Speech Ready!");
  console.log(`üë§ User: ${userRole} | üé§ Speech: ${speechAvailable ? 'ENABLED' : 'DISABLED'}`);
  console.log("üìû CALL MODE: Press phone button or Ctrl+/ for natural conversation!");
  console.log("üî• NATURAL TTS: HTML tags automatically cleaned from speech!");
});
</script>

</body>
</html>