<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DEN¬∑AI - AI Assistant with Visualization</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

<!-- üéØ Chart.js for LLM-generated visualizations -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<style>
/* ================= CORPORATE COLOR SCHEME ================= */
* { 
  box-sizing: border-box; 
  margin: 0;
  padding: 0;
}

:root {
  /* Corporate Colors */
  --color-primary: #dc2626;        /* Corporate Red - Primary */
  --color-secondary: #1e40af;      /* Professional Blue - Secondary */
  --color-accent: #059669;         /* Success Green */
  --color-warning: #d97706;        /* Warning Orange */
  
  /* Neutral Grays */
  --color-gray-900: #111827;       /* Dark Gray/Black */
  --color-gray-800: #1f2937;
  --color-gray-700: #374151;
  --color-gray-600: #4b5563;
  --color-gray-500: #6b7280;
  --color-gray-400: #9ca3af;
  --color-gray-300: #d1d5db;
  --color-gray-200: #e5e7eb;
  --color-gray-100: #f3f4f6;
  --color-gray-50: #f9fafb;
  --color-white: #ffffff;
  
  /* Gradients */
  --gradient-primary: linear-gradient(135deg, var(--color-primary) 0%, var(--color-secondary) 100%);
  --gradient-subtle: linear-gradient(135deg, var(--color-gray-50) 0%, var(--color-white) 100%);
  
  /* Backgrounds */
  --bg-primary: var(--color-white);
  --bg-secondary: var(--color-gray-100);
  --bg-tertiary: var(--color-gray-200);
  --bg-dark: var(--color-gray-900);
  --bg-card: var(--color-white);
  
  /* Text */
  --text-primary: var(--color-gray-900);
  --text-secondary: var(--color-gray-600);
  --text-muted: var(--color-gray-500);
  --text-light: var(--color-white);
  
  /* Borders */
  --border-primary: var(--color-gray-200);
  --border-secondary: var(--color-gray-300);
  --border-focus: var(--color-primary);
  
  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  
  /* Typography */
  --font-primary: 'Inter', system-ui, -apple-system, sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
  
  /* Spacing */
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-5: 1.25rem;
  --space-6: 1.5rem;
  --space-8: 2rem;
  --space-10: 2.5rem;
  --space-12: 3rem;
  
  /* Border radius */
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
  --radius-2xl: 1.5rem;
}

body {
  font-family: var(--font-primary);
  background: var(--bg-secondary);
  color: var(--text-primary);
  display: flex;
  height: 100vh;
  overflow: hidden;
  font-weight: 400;
  line-height: 1.5;
}

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--color-gray-300); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--color-gray-400); }

/* ================= ENHANCED LOADING STATES ================= */
.processing-message {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-4) var(--space-6);
  background: linear-gradient(135deg, var(--color-primary) 0%, #b91c1c 100%);
  color: var(--text-light);
  border-radius: var(--radius-xl);
  font-weight: 600;
  animation: popInMessage 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  box-shadow: 
    0 10px 25px rgba(220, 38, 38, 0.3),
    0 4px 10px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

@keyframes popInMessage {
  0% {
    opacity: 0;
    transform: translateY(30px) scale(0.7);
  }
  50% {
    opacity: 0.8;
    transform: translateY(-5px) scale(1.05);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.processing-spinner {
  width: 22px;
  height: 22px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: var(--text-light);
  animation: spinFast 0.8s linear infinite;
}

@keyframes spinFast {
  to { transform: rotate(360deg); }
}

.processing-message .message-text {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.processing-message .main-text {
  font-size: 15px;
  font-weight: 600;
}

.processing-message .sub-text {
  font-size: 12px;
  opacity: 0.9;
  font-weight: 400;
}

.typing-indicator {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: var(--space-4);
  justify-content: center;
}

.typing-dot {
  width: 10px;
  height: 10px;
  background: var(--color-primary);
  border-radius: 50%;
  animation: typingBounce 1.4s infinite ease-in-out;
  box-shadow: 0 2px 6px rgba(220, 38, 38, 0.3);
}

.typing-dot:nth-child(1) { animation-delay: 0s; }
.typing-dot:nth-child(2) { animation-delay: 0.2s; }
.typing-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes typingBounce {
  0%, 60%, 100% { 
    transform: translateY(0) scale(1); 
    opacity: 0.5; 
  }
  30% { 
    transform: translateY(-10px) scale(1.2); 
    opacity: 1; 
  }
}

/* Enhanced bubble for processing state */
.processing-bubble {
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
  border: 2px solid var(--color-primary);
  position: relative;
  overflow: hidden;
}

.processing-bubble::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(220, 38, 38, 0.1), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { left: -100%; }
  100% { left: 100%; }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ================= CHART VISUALIZATION STYLES ================= */
.chart-container {
  position: relative;
  height: 400px;
  width: 100%;
  margin: var(--space-6) 0;
  padding: var(--space-4);
  background: var(--bg-card);
  border-radius: var(--radius-xl);
  border: 1px solid var(--border-primary);
  box-shadow: var(--shadow-md);
}

.chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 1px solid var(--border-secondary);
}

.chart-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--color-primary);
  font-family: var(--font-primary);
}

.chart-actions {
  display: flex;
  gap: var(--space-2);
}

.chart-action-btn {
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-md);
  cursor: pointer;
  font-size: 12px;
  color: var(--text-muted);
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: var(--space-1);
}

.chart-action-btn:hover {
  background: var(--color-primary);
  color: var(--text-light);
  transform: scale(1.05);
}

.chart-canvas-wrapper {
  position: relative;
  height: 320px;
  width: 100%;
}

.chart-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-3);
  color: var(--text-muted);
}

.chart-loading .spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--color-gray-300);
  border-top: 3px solid var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.chart-error {
  text-align: center;
  padding: var(--space-8);
  color: var(--color-secondary);
  background: rgba(220, 38, 38, 0.05);
  border-radius: var(--radius-lg);
  border: 1px solid rgba(220, 38, 38, 0.2);
}

.chart-footer {
  margin-top: var(--space-4);
  padding-top: var(--space-3);
  border-top: 1px solid var(--border-secondary);
  font-size: 12px;
  color: var(--text-muted);
  text-align: center;
  font-style: italic;
}

/* Chart animation */
@keyframes chartFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chart-container {
  animation: chartFadeIn 0.5s ease-out;
}

/* Mobile responsive charts */
@media (max-width: 768px) {
  .chart-container {
    height: 350px;
    margin: var(--space-4) 0;
    padding: var(--space-3);
  }
  
  .chart-canvas-wrapper {
    height: 280px;
  }
  
  .chart-header {
    flex-direction: column;
    gap: var(--space-2);
    align-items: flex-start;
  }
  
  .chart-actions {
    width: 100%;
    justify-content: flex-end;
  }
}

/* ================= EXISTING STYLES CONTINUE... ================= */
.call-mode-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, var(--color-gray-900) 0%, var(--color-primary) 100%);
  backdrop-filter: blur(20px);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  animation: callFadeIn 0.5s ease;
}

.call-mode-overlay.active {
  display: flex;
}

@keyframes callFadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

.call-interface {
  text-align: center;
  max-width: 500px;
  padding: var(--space-12);
  background: rgba(255, 255, 255, 0.95);
  border-radius: var(--radius-2xl);
  box-shadow: var(--shadow-xl);
  border: 1px solid var(--border-primary);
}

.call-avatar {
  width: 120px;
  height: 120px;
  margin: 0 auto var(--space-8);
  background: var(--gradient-primary);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-mono);
  font-size: 48px;
  font-weight: 800;
  color: var(--text-light);
  position: relative;
  animation: callPulse 2s infinite ease-in-out;
}

@keyframes callPulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(30, 64, 175, 0.7); }
  50% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(30, 64, 175, 0); }
}

.call-status {
  font-size: 24px;
  font-weight: 700;
  color: var(--color-primary);
  margin-bottom: var(--space-4);
  font-family: var(--font-primary);
}

.call-transcript {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-6);
  margin: var(--space-6) 0;
  min-height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-style: italic;
  color: var(--text-secondary);
  border: 1px solid var(--border-primary);
}

.call-controls {
  display: flex;
  gap: var(--space-6);
  justify-content: center;
  margin-top: var(--space-8);
}

.call-control-btn {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  font-size: 24px;
  box-shadow: var(--shadow-md);
}

.call-control-btn.end-call {
  background: var(--color-secondary);
  color: var(--text-light);
}

.call-control-btn.end-call:hover {
  background: #b91c1c;
  transform: scale(1.1);
}

.call-control-btn.mute {
  background: var(--bg-card);
  color: var(--text-secondary);
  border: 2px solid var(--border-primary);
}

.call-control-btn.mute:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.call-control-btn.mute.active {
  background: var(--color-secondary);
  color: var(--text-light);
}

/* ================= AUDIO VISUALIZER ================= */
.audio-visualizer {
  display: flex;
  gap: 3px;
  align-items: center;
  height: 30px;
  margin: var(--space-6) 0;
  justify-content: center;
}

.audio-bar {
  width: 4px;
  background: var(--color-primary);
  border-radius: 2px;
  transition: height 0.1s ease;
  min-height: 4px;
}

.audio-bar.active {
  animation: audioWave 1s ease-in-out infinite;
}

@keyframes audioWave {
  0%, 100% { height: 6px; }
  50% { height: 24px; }
}

/* ================= VOLUME INDICATOR ================= */
.volume-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-6);
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.9);
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-lg);
  font-size: 12px;
  color: var(--text-light);
  font-family: var(--font-mono);
  opacity: 0;
  transition: opacity 0.3s ease;
  box-shadow: var(--shadow-lg);
}

.volume-indicator.show {
  opacity: 1;
}

/* ================= SIDEBAR ================= */
.sidebar {
  width: 300px;
  background: var(--bg-card);
  border-right: 1px solid var(--border-primary);
  padding: var(--space-6);
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
  box-shadow: var(--shadow-sm);
}

.sidebar-header {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  padding: var(--space-6);
  background: var(--gradient-subtle);
  border-radius: var(--radius-xl);
  border: 1px solid var(--border-primary);
  box-shadow: var(--shadow-sm);
}

.sidebar-header .logo {
  width: 42px;
  height: 42px;
  background: var(--gradient-primary);
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-mono);
  font-weight: 800;
  font-size: 16px;
  color: var(--text-light);
  box-shadow: var(--shadow-md);
}

.sidebar-header .title {
  font-family: var(--font-primary);
  font-weight: 700;
  font-size: 18px;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  position: relative;
}

.sidebar-header .title .middle-dot {
  color: var(--color-primary);
  font-weight: 900;
  font-size: 24px;
  line-height: 1;
  margin: 0 2px;
  display: inline-block;
  vertical-align: middle;
}

#appTitle .middle-dot {
  color: var(--color-primary);
  font-weight: 900;
  font-size: 28px;
  line-height: 1;
  margin: 0 3px;
  display: inline-block;
  vertical-align: middle;
}

#landing h1 .middle-dot {
  color: var(--color-primary);
  font-weight: 900;
  font-size: 56px;
  line-height: 1;
  margin: 0 4px;
  display: inline-block;
  vertical-align: middle;
}

.new-chat {
  background: var(--gradient-primary);
  border: none;
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-xl);
  color: var(--text-light);
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  transition: all 0.3s ease;
  box-shadow: var(--shadow-md);
  font-family: var(--font-primary);
}

.new-chat:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.new-chat svg {
  width: 18px;
  height: 18px;
}

.history {
  overflow-y: auto;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.session-item {
  padding: var(--space-4) var(--space-5);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all 0.2s ease;
  background: var(--bg-secondary);
  border: 1px solid transparent;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.session-item:hover {
  background: rgba(30, 64, 175, 0.05);
  border-color: var(--color-primary);
  transform: translateX(2px);
}

.session-item.active {
  background: rgba(30, 64, 175, 0.1);
  border-color: var(--color-primary);
  font-weight: 600;
}

.session-item .title {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  font-size: 13px;
  color: var(--text-secondary);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
}

/* Remove pin indicators - use sections instead */
.session-item .pin-indicator {
  display: none;
}

.session-item .pin-icon {
  display: none;
}

/* Section headers for organized sidebar */
.session-section {
  margin: var(--space-6) 0 var(--space-3) 0;
}

.section-header {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 0 var(--space-2);
  margin-bottom: var(--space-2);
}

.session-section:first-child .section-header {
  margin-top: 0;
}

.session-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}

.session-actions {
  display: none;
  gap: 4px;
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-card);
  padding: 4px;
  border-radius: var(--radius-md);
  border: 1px solid var(--border-primary);
  z-index: 10;
  box-shadow: var(--shadow-md);
}

.session-item:hover .session-actions {
  display: flex;
}

.session-action-btn {
  background: transparent;
  border: none;
  padding: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: all 0.2s ease;
}

.session-action-btn:hover {
  background: var(--bg-tertiary);
  transform: scale(1.1);
}

.session-action-btn svg {
  width: 14px;
  height: 14px;
  color: var(--text-muted);
}

.session-action-btn:hover svg {
  color: var(--text-primary);
}

.session-action-btn.pin-btn.active svg {
  color: var(--color-secondary);
  fill: var(--color-secondary);
}

.session-action-btn.delete-btn:hover svg {
  color: var(--color-secondary);
}

/* ================= MAIN CONTENT ================= */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--bg-primary);
}

.header {
  padding: var(--space-6) var(--space-8);
  border-bottom: 1px solid var(--border-primary);
  background: var(--bg-card);
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: var(--shadow-sm);
}

#appTitle {
  font-size: 24px;
  font-weight: 800;
  display: flex;
  align-items: center;
  gap: var(--space-4);
  color: var(--text-primary);
  font-family: var(--font-primary);
}

#appTitle .logo-icon {
  width: 48px;
  height: 48px;
  background: var(--gradient-primary);
  border-radius: var(--radius-xl);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-mono);
  font-weight: 900;
  font-size: 20px;
  color: var(--text-light);
  box-shadow: var(--shadow-md);
}

.header-right {
  display: flex;
  gap: var(--space-4);
  align-items: center;
}

.speech-controls {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.speech-btn {
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  padding: var(--space-3);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 48px;
  min-height: 48px;
  box-shadow: var(--shadow-sm);
}

.speech-btn:hover {
  background: rgba(30, 64, 175, 0.1);
  border-color: var(--color-primary);
  transform: scale(1.05);
}

.speech-btn.listening {
  background: var(--color-primary);
  border-color: var(--color-primary);
  color: var(--text-light);
  animation: pulse 2s infinite;
}

.speech-btn.call-mode {
  background: var(--color-accent);
  border-color: var(--color-accent);
  color: var(--text-light);
  animation: callGlow 2s infinite;
}

@keyframes callGlow {
  0%, 100% { box-shadow: 0 0 0 0 rgba(5, 150, 105, 0.7); }
  50% { box-shadow: 0 0 0 10px rgba(5, 150, 105, 0); }
}

.speech-btn svg {
  width: 20px;
  height: 20px;
  color: var(--text-secondary);
  transition: color 0.3s ease;
}

.speech-btn:hover svg,
.speech-btn.listening svg,
.speech-btn.call-mode svg {
  color: currentColor;
}

.user-badge {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-2) var(--space-4);
  background: var(--bg-secondary);
  border-radius: var(--radius-lg);
  border: 1px solid var(--border-primary);
  font-size: 12px;
  font-weight: 600;
  font-family: var(--font-mono);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  box-shadow: var(--shadow-sm);
}

.user-badge.hr {
  color: var(--color-secondary);
  border-color: var(--color-secondary);
  background: rgba(220, 38, 38, 0.1);
}

.user-badge .badge-icon {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--color-accent);
  animation: pulse 2s infinite;
}

.user-badge.hr .badge-icon {
  background: var(--color-secondary);
}

/* ================= LANDING PAGE ================= */
#landing {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: var(--space-12);
  gap: var(--space-8);
}

#landing h1 {
  font-size: 48px;
  font-weight: 900;
  color: var(--text-primary);
  text-align: center;
  line-height: 1.1;
  font-family: var(--font-primary);
  margin-bottom: var(--space-4);
}

#landing .subtitle {
  font-size: 18px;
  color: var(--text-secondary);
  font-weight: 400;
  text-align: center;
  max-width: 600px;
  font-family: var(--font-primary);
  line-height: 1.6;
}

.search-box {
  width: 100%;
  max-width: 600px;
  display: flex;
  align-items: center;
  background: var(--bg-card);
  border: 2px solid var(--border-primary);
  border-radius: var(--radius-2xl);
  padding: var(--space-2);
  box-shadow: var(--shadow-lg);
  transition: all 0.3s ease;
  gap: var(--space-2);
}

.search-box:focus-within {
  border-color: var(--color-primary);
  box-shadow: var(--shadow-xl);
}

.search-box input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 16px;
  padding: var(--space-4) var(--space-6);
  font-family: var(--font-primary);
  font-weight: 500;
}

.search-box input::placeholder {
  color: var(--text-muted);
}

.search-box .speech-btn {
  background: transparent;
  border: none;
  margin: 0;
  box-shadow: none;
  min-width: 44px;
  min-height: 44px;
}

.search-box button {
  background: var(--gradient-primary);
  border: none;
  color: var(--text-light);
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-xl);
  cursor: pointer;
  font-weight: 700;
  font-size: 15px;
  transition: all 0.3s ease;
  font-family: var(--font-primary);
  box-shadow: var(--shadow-md);
}

.search-box button:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

/* ================= CHAT INTERFACE ================= */
#chat {
  display: none;
  flex: 1;
  flex-direction: column;
  overflow: hidden;
}

.messages {
  flex: 1;
  padding: var(--space-6) var(--space-8);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
}

.msg {
  display: flex;
  gap: var(--space-4);
  max-width: 75%;
  animation: slideInMessage 0.4s ease-out;
  position: relative;
}

@keyframes slideInMessage {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes popInMessage {
  0% {
    opacity: 0;
    transform: translateY(30px) scale(0.7);
  }
  50% {
    opacity: 0.8;
    transform: translateY(-5px) scale(1.05);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes spinFast {
  to { transform: rotate(360deg); }
}

@keyframes typingBounce {
  0%, 60%, 100% { 
    transform: translateY(0) scale(1); 
    opacity: 0.5; 
  }
  30% { 
    transform: translateY(-10px) scale(1.2); 
    opacity: 1; 
  }
}

@keyframes shimmer {
  0% { left: -100%; }
  100% { left: 100%; }
}

.user-msg {
  margin-left: auto;
  flex-direction: row-reverse;
}

.avatar {
  width: 40px;
  height: 40px;
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 700;
  font-family: var(--font-mono);
  flex-shrink: 0;
  box-shadow: var(--shadow-md);
  color: var(--text-light);
  letter-spacing: 0.05em;
}

.user .avatar {
  background: var(--gradient-primary);
}

.bot .avatar {
  background: var(--color-gray-600);
}

.bubble {
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-xl);
  line-height: 1.6;
  word-break: break-word;
  overflow-wrap: anywhere;
  font-size: 14px;
  font-weight: 500;
  position: relative;
  box-shadow: var(--shadow-sm);
}

.user .bubble {
  background: var(--color-primary);
  color: var(--text-light);
  border-bottom-right-radius: var(--radius-sm);
  white-space: pre-wrap;
  font-weight: 600;
}

.bot .bubble {
  background: #fafafa;
  border: 1px solid var(--border-primary);
  color: var(--text-primary);
  border-bottom-left-radius: var(--radius-sm);
}

.message-actions {
  position: absolute;
  top: -8px;
  right: 8px;
  background: var(--color-white);
  border: 1px solid var(--border-secondary);
  border-radius: var(--radius-md);
  padding: 2px;
  display: none;
  gap: 2px;
  opacity: 0;
  transition: opacity 0.2s ease;
  box-shadow: var(--shadow-sm);
}

.msg:hover .message-actions {
  display: flex;
  opacity: 1;
}

.action-btn {
  background: transparent;
  border: none;
  padding: 6px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-muted);
}

.action-btn:hover {
  background: var(--color-primary);
  color: var(--text-light);
  transform: scale(1.1);
}

.action-btn svg {
  width: 16px;
  height: 16px;
}

/* HTML format display in bubbles */
.bubble h3 {
  margin: 16px 0 10px 0;
  font-size: 18px;
  font-weight: 800;
  color: var(--color-primary);
  line-height: 1.3;
}

.bubble h3:first-child {
  margin-top: 0;
}

.bubble p {
  margin: 0 0 12px 0;
  line-height: 1.6;
}

.bubble p:last-child {
  margin-bottom: 0;
}

.bubble ul,
.bubble ol {
  margin: 8px 0 12px 0;
  padding-left: 20px;
}

.bubble li {
  margin-bottom: 8px;
  line-height: 1.5;
}

.bubble li:last-child {
  margin-bottom: 0;
}

.bubble strong,
.bubble b {
  color: var(--text-primary);
  font-weight: 700;
}

.bubble em,
.bubble i {
  color: var(--text-muted);
  font-style: italic;
}

/* ================= INPUT BOX ================= */
.input-box {
  padding: var(--space-6) var(--space-8);
  display: flex;
  gap: var(--space-4);
  border-top: 1px solid var(--border-primary);
  background: var(--bg-card);
  align-items: center;
  box-shadow: var(--shadow-sm);
}

.input-container {
  flex: 1;
  display: flex;
  align-items: center;
  background: var(--bg-secondary);
  border: 2px solid var(--border-primary);
  border-radius: var(--radius-lg);
  padding: var(--space-2);
  transition: all 0.3s ease;
}

.input-container:focus-within {
  border-color: var(--color-primary);
  background: var(--bg-primary);
  box-shadow: 0 0 0 1px var(--color-primary);
}

.input-container input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: var(--text-primary);
  font-size: 14px;
  font-family: var(--font-primary);
  font-weight: 500;
  padding: var(--space-3) var(--space-4);
}

.input-container input::placeholder {
  color: var(--text-muted);
}

.input-container input:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.input-container .speech-btn {
  background: transparent;
  border: none;
  margin: 0;
  box-shadow: none;
  min-width: 36px;
  min-height: 36px;
}

.input-box button {
  background: var(--gradient-primary);
  border: none;
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-xl);
  color: var(--text-light);
  cursor: pointer;
  font-weight: 700;
  font-size: 14px;
  font-family: var(--font-primary);
  transition: all 0.3s ease;
  box-shadow: var(--shadow-md);
}

.input-box button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.input-box button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.loading-indicator {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: var(--text-light);
  animation: spin 1s linear infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* ================= RESPONSIVE ================= */
@media (max-width: 768px) {
  .sidebar { width: 260px; }
  #landing h1 { font-size: 36px; }
  .search-box { max-width: 95%; }
  .msg { max-width: 90%; }
  .messages { padding: var(--space-4); }
  .input-box { padding: var(--space-4); }
}

@media (max-width: 640px) {
  .sidebar { display: none; }
  .header { padding: var(--space-4); }
  #appTitle { font-size: 18px; }
  #landing h1 { font-size: 28px; }
  .search-box input { font-size: 14px; }
}
</style>
</head>

<body>

<!-- Call Mode Overlay -->
<div class="call-mode-overlay" id="callModeOverlay">
  <div class="call-interface">
    <div class="call-avatar">AI</div>
    <div class="call-status" id="callStatus">üîä Call Mode Active</div>
    <div class="call-transcript" id="callTranscript">
      Bicara sekarang... DEN¬∑AI sedang mendengarkan
    </div>
    
    <!-- Audio Visualizer -->
    <div class="audio-visualizer" id="audioVisualizer">
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
      <div class="audio-bar"></div>
    </div>
    
    <div class="call-controls">
      <button class="call-control-btn mute" id="muteBtn" title="Mute">üé§</button>
      <button class="call-control-btn end-call" id="endCallBtn" title="End Call">üìû</button>
    </div>
  </div>
</div>

<!-- Volume Indicator -->
<div class="volume-indicator" id="volumeIndicator">
  üîä Volume: <span id="volumeLevel">100</span>%
</div>

<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <div class="logo">AI</div>
    <span class="title">DEN<span class="middle-dot">¬∑</span>AI</span>
  </div>
  
  <button class="new-chat" onclick="newChat()">
    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
    </svg>
    <span>New Conversation</span>
  </button>
  
  <div class="history" id="sessionList"></div>
</div>

<div class="main">
  <div class="header">
    <span id="appTitle">
      <div class="logo-icon">AI</div>
      <span>DEN<span class="middle-dot">¬∑</span>AI Assistant</span>
    </span>
    
    <div class="header-right">
      <div class="speech-controls">
        <!-- Real-time Call Mode Button -->
        <button class="speech-btn" id="callModeBtn" title="Real-time Call Mode">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
          </svg>
        </button>
      </div>
      
      <div class="user-badge" id="userBadge">
        <div class="badge-icon"></div>
        <span id="userRole">Loading...</span>
      </div>
    </div>
  </div>

  <div id="landing">
    <h1>DEN<span class="middle-dot">¬∑</span>AI Assistant</h1>
    <p class="subtitle">Your intelligent AI assistant for company procedures, policies, and data. Experience natural conversations with voice support.</p>
    <div class="search-box">
      <input id="landingInput" placeholder="Type your question or use voice input..." />
      <button class="speech-btn" id="landingSpeechBtn" title="Voice Input">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
        </svg>
      </button>
      <button onclick="startFromLanding()">Submit</button>
    </div>
  </div>

  <div id="chat">
    <div class="messages" id="messages"></div>
    <div class="input-box">
      <div class="input-container">
        <input id="chatInput" placeholder="Type your question or use voice input..." />
        <button class="speech-btn" id="chatSpeechBtn" title="Voice Input">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
          </svg>
        </button>
      </div>
      <button id="sendButton" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
/* ================= GLOBAL STATE ================= */
let activeChatId = null;
let isWaitingForResponse = false;
let conversationHistory = [];
let userRole = null;
let isHR = false;

// Speech system state
let speechRecognition = null;
let isListening = false;
let currentSpeechButton = null;
let currentInput = null;
let isSpeaking = false;

// Real-time call mode state
let isCallModeActive = false;
let continuousListening = false;
let callSession = null;
let isProcessingCall = false;
let currentAudio = null;
let processingAudio = null;

// Input mode detection
let isTextOnlyMode = false;
let isVoiceToTextMode = false;

/* ================= DOM CACHE ================= */
const landing = document.getElementById("landing");
const chat = document.getElementById("chat");
const messages = document.getElementById("messages");
const chatInput = document.getElementById("chatInput");
const landingInput = document.getElementById("landingInput");
const sendButton = document.getElementById("sendButton");
const userBadge = document.getElementById("userBadge");
const userRoleText = document.getElementById("userRole");

// Call mode elements
const callModeOverlay = document.getElementById("callModeOverlay");
const callStatus = document.getElementById("callStatus");
const callTranscript = document.getElementById("callTranscript");
const callModeBtn = document.getElementById("callModeBtn");
const endCallBtn = document.getElementById("endCallBtn");
const muteBtn = document.getElementById("muteBtn");
const audioVisualizer = document.getElementById("audioVisualizer");
const volumeIndicator = document.getElementById("volumeIndicator");

// Speech buttons
const landingSpeechBtn = document.getElementById("landingSpeechBtn");
const chatSpeechBtn = document.getElementById("chatSpeechBtn");

/* ================= CHART VISUALIZATION SYSTEM ================= */
let activeCharts = new Map(); // Store active Chart.js instances

async function renderLLMGeneratedChart(chartConfig, container) {
  /**
   * Render LLM-generated Chart.js configuration
   * Handles all chart types with professional styling
   */
  console.log('üìä Rendering LLM-generated chart:', chartConfig.type);
  
  try {
    // Create canvas element
    const canvas = document.createElement('canvas');
    canvas.id = `chart_${Date.now()}`;
    container.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    
    // Clean up function references in config (LLM sometimes generates function strings)
    const cleanConfig = cleanChartConfig(chartConfig);
    
    // Create Chart.js instance
    const chart = new Chart(ctx, cleanConfig);
    
    // Store chart instance for cleanup
    activeCharts.set(canvas.id, chart);
    
    console.log('‚úÖ Chart rendered successfully');
    return chart;
    
  } catch (error) {
    console.error('‚ùå Chart rendering error:', error);
    container.innerHTML = `
      <div class="chart-error">
        <h3>‚ùå Chart Error</h3>
        <p>Failed to render visualization: ${error.message}</p>
      </div>
    `;
    return null;
  }
}

function cleanChartConfig(config) {
  /**
   * Clean LLM-generated config for Chart.js compatibility
   * Handles function strings and ensures proper formatting
   */
  const cleaned = JSON.parse(JSON.stringify(config));
  
  // Handle tooltip callbacks that might be function strings
  if (cleaned.options?.plugins?.tooltip?.callbacks) {
    const callbacks = cleaned.options.plugins.tooltip.callbacks;
    
    // Clean up function strings
    Object.keys(callbacks).forEach(key => {
      if (typeof callbacks[key] === 'string' && callbacks[key].includes('function')) {
        // Remove function string to prevent errors
        delete callbacks[key];
      }
    });
  }
  
  // Ensure proper responsive settings
  cleaned.options = cleaned.options || {};
  cleaned.options.responsive = true;
  cleaned.options.maintainAspectRatio = false;
  
  return cleaned;
}

function createChartContainer(title = "Data Visualization") {
  /**
   * Create professional chart container with actions
   */
  const container = document.createElement('div');
  container.className = 'chart-container';
  container.innerHTML = `
    <div class="chart-header">
      <div class="chart-title">${title}</div>
      <div class="chart-actions">
        <button class="chart-action-btn" onclick="exportChart(this)" title="Export PNG">
          <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
            <path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"/>
          </svg>
          Export
        </button>
        <button class="chart-action-btn" onclick="toggleChart(this)" title="Toggle View">
          <svg width="14" height="14" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
          </svg>
          View
        </button>
      </div>
    </div>
    <div class="chart-canvas-wrapper">
      <div class="chart-loading">
        <div class="spinner"></div>
        <span>Generating visualization...</span>
      </div>
    </div>
    <div class="chart-footer">
      Generated by DEN¬∑AI using LLM-powered visualization
    </div>
  `;
  
  return container;
}

async function exportChart(button) {
  /**
   * Export chart as PNG image
   */
  try {
    const container = button.closest('.chart-container');
    const canvas = container.querySelector('canvas');
    
    if (!canvas) {
      alert('No chart found to export');
      return;
    }
    
    // Create download link
    const link = document.createElement('a');
    link.download = `denai_chart_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log('‚úÖ Chart exported successfully');
    
  } catch (error) {
    console.error('‚ùå Chart export error:', error);
    alert('Failed to export chart');
  }
}

function toggleChart(button) {
  /**
   * Toggle between chart and table view
   */
  try {
    const container = button.closest('.chart-container');
    const wrapper = container.querySelector('.chart-canvas-wrapper');
    
    // Simple toggle for now - could expand to show data table
    if (wrapper.style.display === 'none') {
      wrapper.style.display = 'block';
      button.innerHTML = button.innerHTML.replace('Show', 'Hide');
    } else {
      wrapper.style.display = 'none';  
      button.innerHTML = button.innerHTML.replace('Hide', 'Show');
    }
    
  } catch (error) {
    console.error('‚ùå Chart toggle error:', error);
  }
}

async function askWithVisualization(question) {
  /**
   * Enhanced ask function that supports LLM-generated visualizations
   */
  console.log('üéØ Asking with visualization support:', question);
  
  try {
    // Show processing message
    let processingMessage = showProcessingMessage();
    
    const payload = {
      question: question,
      session_id: activeChatId,
      user_role: userRole || "Employee",
      enable_visualization: true
    };

    const response = await fetch("http://127.0.0.1:8000/hr/analyze-with-visualization", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(payload),
      signal: AbortSignal.timeout(45000)
    });

    // Remove processing message
    if (processingMessage && processingMessage.parentNode) {
      processingMessage.remove();
    }

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    
    // Handle errors
    if (data.error || !data.authorized) {
      addMessage("bot", data.text_response || "‚ùå Request failed");
      return;
    }
    
    // Add text response
    const messageElement = addMessage("bot", data.text_response);
    
    // Add visualization if available
    if (data.has_visualization && data.chart_config) {
      await renderVisualizationInChat(data);
    }
    
    // Auto-speak in appropriate modes
    setTimeout(() => {
      if (isCallModeActive) {
        speakText(data.text_response);
      } else if (!isTextOnlyMode && !isVoiceToTextMode) {
        speakText(data.text_response);
      }
    }, 800);
    
  } catch (err) {
    console.error('‚ùå Visualization request error:', err);
    if (processingMessage && processingMessage.parentNode) {
      processingMessage.remove();
    }
    
    // Fallback to regular ask
    console.log('üîÑ Falling back to regular ask...');
    return askBackend(question);
  }
}

async function renderVisualizationInChat(data) {
  /**
   * Render LLM-generated visualization in chat interface
   */
  console.log('üìä Rendering visualization in chat:', data.chart_type);
  
  try {
    // Create chart container
    const title = `${data.chart_type?.toUpperCase()} Chart - ${data.query_info?.explanation || 'HR Analytics'}`;
    const chartContainer = createChartContainer(title);
    
    // Add to messages
    messages.appendChild(chartContainer);
    messages.scrollTop = messages.scrollHeight;
    
    // Get canvas wrapper and clear loading
    const canvasWrapper = chartContainer.querySelector('.chart-canvas-wrapper');
    canvasWrapper.innerHTML = '';
    
    // Render the chart
    await renderLLMGeneratedChart(data.chart_config, canvasWrapper);
    
    // Update footer with reasoning if available
    if (data.visualization_reasoning) {
      const footer = chartContainer.querySelector('.chart-footer');
      footer.textContent = `AI Reasoning: ${data.visualization_reasoning}`;
    }
    
    console.log('‚úÖ Visualization rendered in chat successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to render visualization in chat:', error);
  }
}

/* ================= ENHANCED TOOL EXECUTION ================= */
function showProcessingMessage() {
  const processingDiv = document.createElement("div");
  processingDiv.className = "msg bot";
  processingDiv.innerHTML = `
    <div class="avatar">AI</div>
    <div class="bubble processing-message">
      <div class="processing-spinner"></div>
      <div class="message-text">
        <div class="main-text">Processing your request...</div>
        <div class="sub-text">Please wait a moment</div>
      </div>
    </div>
  `;
  messages.appendChild(processingDiv);
  messages.scrollTop = messages.scrollHeight;
  
  // Force repaint to ensure animation is visible
  processingDiv.offsetHeight;
  
  return processingDiv;
}

function showTypingIndicator() {
  const typingDiv = document.createElement("div");
  typingDiv.className = "msg bot typing-msg";
  typingDiv.innerHTML = `
    <div class="avatar">AI</div>
    <div class="bubble processing-bubble">
      <div class="typing-indicator">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>
  `;
  messages.appendChild(typingDiv);
  messages.scrollTop = messages.scrollHeight;
  return typingDiv;
}

/* ================= AUDIO FEEDBACK SYSTEM ================= */
async function playProcessingFeedback() {
  if (isTextOnlyMode) {
    console.log('üîá Text-only mode: No audio feedback');
    return;
  }

  try {
    console.log('üîä Playing processing feedback...');
    
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance("Processing your request, please wait.");
      utterance.lang = 'en-US';
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 0.8;
      
      utterance.onstart = () => console.log('üîä Processing feedback started');
      utterance.onend = () => console.log('üîä Processing feedback ended');
      
      window.speechSynthesis.speak(utterance);
      processingAudio = utterance;
    }
  } catch (error) {
    console.error('üîä Failed to play processing feedback:', error);
  }
}

function stopProcessingFeedback() {
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
  processingAudio = null;
}

/* ================= SPEECH RECOGNITION SYSTEM ================= */
function initializeSpeechRecognition() {
  if ('webkitSpeechRecognition' in window) {
    speechRecognition = new webkitSpeechRecognition();
  } else if ('SpeechRecognition' in window) {
    speechRecognition = new SpeechRecognition();
  } else {
    console.warn('Speech recognition not supported');
    document.querySelectorAll('.speech-btn').forEach(btn => {
      btn.style.display = 'none';
    });
    return false;
  }

  speechRecognition.continuous = true;
  speechRecognition.interimResults = true;
  speechRecognition.lang = 'id-ID';
  speechRecognition.maxAlternatives = 1;

  speechRecognition.onstart = function() {
    console.log('[STT] ‚úÖ Speech recognition STARTED');
    isListening = true;
    updateSpeechUI(true);
    
    if (isCallModeActive) {
      callStatus.textContent = 'üé§ Listening...';
      showAudioVisualization(true);
    }
  };

  speechRecognition.onresult = function(event) {
    console.log('[STT] Results received, processing...');
    let interimTranscript = '';
    let finalTranscript = '';

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript;
      
      if (event.results[i].isFinal) {
        finalTranscript += transcript;
      } else {
        interimTranscript += transcript;
      }
    }

    const displayText = finalTranscript || interimTranscript;
    
    if (isCallModeActive) {
      callTranscript.textContent = displayText || 'Listening...';
    }
    
    if (currentInput && displayText) {
      currentInput.value = displayText;
    }

    if (finalTranscript) {
      console.log('[STT] ‚úÖ Final transcript received:', finalTranscript);
      
      if (isCallModeActive) {
        handleCallModeInput(finalTranscript.trim());
      } else if (currentInput) {
        isVoiceToTextMode = true;
        isTextOnlyMode = false;
        
        currentInput.value = finalTranscript.trim();
        setTimeout(() => {
          if (currentInput === landingInput) {
            startFromLanding();
          } else {
            sendMessage();
          }
        }, 500);
      }
    }
  };

  speechRecognition.onerror = function(event) {
    console.error('[STT] ‚ùå Speech recognition error:', event.error);
    
    if (event.error === 'not-allowed') {
      alert('Microphone access is required. Please allow microphone access and try again.');
    } else if (event.error === 'no-speech') {
      if (isCallModeActive && continuousListening) {
        setTimeout(() => restartCallListening(), 1000);
      }
    }
  };

  speechRecognition.onend = function() {
    console.log('[STT] Speech recognition ended');
    isListening = false;
    updateSpeechUI(false);
    
    if (isCallModeActive) {
      showAudioVisualization(false);
      if (continuousListening && !isProcessingCall) {
        setTimeout(() => restartCallListening(), 500);
      }
    }
  };

  return true;
}

/* ================= NATURAL TTS SYSTEM ================= */
async function speakText(text, options = {}) {
  console.log('üîä speakText called with:', text ? text.substring(0, 50) : 'null/empty');
  
  if (isTextOnlyMode || isVoiceToTextMode) {
    console.log('üîá Skipping TTS - Text-only or Voice-to-text mode');
    return null;
  }
  
  if (!text || text.trim().length === 0) {
    console.error('üîä No text provided to speak');
    return null;
  }

  console.log('üîä Calling NATURAL TTS API');

  try {
    if (currentAudio) {
      currentAudio.pause();
      currentAudio = null;
    }

    showVolumeIndicator();

    const requestPayload = {
      text: text,
      language: options.language || 'id',
      voice: options.voice || 'indonesian',
      slow: options.slow || false
    };
    
    console.log('üîä Natural TTS Request');
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
      console.error('üîä ‚ùå TTS request timeout (15s)');
    }, 15000);

    const response = await fetch('http://127.0.0.1:8000/speech/text-to-speech', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestPayload),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('üîä TTS API failed:', response.status, errorText);
      throw new Error(`TTS API failed: ${response.status}`);
    }

    const audioBlob = await response.blob();
    console.log('üîä ‚úÖ Received natural audio blob:', audioBlob.size, 'bytes');

    if (audioBlob.size === 0) {
      throw new Error('Received empty audio blob');
    }

    const audioUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(audioUrl);
    currentAudio = audio;
    
    audio.volume = 0.9;
    audio.preload = 'auto';
    
    return new Promise((resolve, reject) => {
      audio.onloadeddata = () => {
        console.log('üîä ‚úÖ Natural audio loaded, duration:', audio.duration, 'seconds');
      };
      
      audio.onplay = () => {
        console.log('üîä ‚úÖ Natural speech playback STARTED');
        isSpeaking = true;
        
        if (isCallModeActive) {
          callStatus.textContent = 'üîä DEN¬∑AI Speaking...';
        }
      };

      audio.onended = () => {
        console.log('üîä ‚úÖ Natural speech playback ENDED');
        isSpeaking = false;
        URL.revokeObjectURL(audioUrl);
        currentAudio = null;
        hideVolumeIndicator();
        
        if (isCallModeActive && !isProcessingCall) {
          setTimeout(() => {
            if (isCallModeActive && continuousListening) {
              callStatus.textContent = 'üé§ Listening...';
              callTranscript.textContent = 'Bicara lagi...';
              restartCallListening();
            }
          }, 500);
        }
        
        resolve(audio);
      };

      audio.onerror = (error) => {
        console.error('üîä ‚ùå Audio playback error:', error);
        isSpeaking = false;
        URL.revokeObjectURL(audioUrl);
        currentAudio = null;
        hideVolumeIndicator();
        reject(error);
      };

      audio.play().catch(playError => {
        console.error('üîä ‚ùå Audio.play() failed:', playError);
        
        if (playError.name === 'NotAllowedError') {
          const userConfirm = confirm('Audio is blocked by browser. Click OK to enable audio playback.');
          if (userConfirm) {
            audio.play().then(() => resolve(audio)).catch(reject);
          } else {
            reject(playError);
          }
        } else {
          reject(playError);
        }
      });
    });
    
  } catch (error) {
    console.error('üîä ‚ùå Natural TTS error:', error);
    hideVolumeIndicator();
    
    if (error.name === 'AbortError') {
      console.error('üîä TTS request was aborted (timeout)');
      return null;
    }
    
    console.log('üîä Attempting browser TTS fallback...');
    return speakTextFallback(text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim());
  }
}

function speakTextFallback(text) {
  if (isTextOnlyMode || isVoiceToTextMode) {
    console.log('üîá Skipping fallback TTS - Text-only or Voice-to-text mode');
    return null;
  }

  try {
    if (!window.speechSynthesis) {
      console.error('üîä Browser TTS not available');
      return null;
    }

    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'id-ID';
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 0.9;

    utterance.onstart = () => {
      isSpeaking = true;
      console.log('üîä Browser TTS fallback started');
      showVolumeIndicator();
    };

    utterance.onend = () => {
      isSpeaking = false;
      console.log('üîä Browser TTS fallback ended');
      hideVolumeIndicator();
    };

    utterance.onerror = (error) => {
      console.error('üîä Browser TTS error:', error.error);
      isSpeaking = false;
      hideVolumeIndicator();
    };

    window.speechSynthesis.speak(utterance);
    return utterance;
    
  } catch (error) {
    console.error('üîä Fallback TTS failed:', error);
    return null;
  }
}

function stopTextToSpeech() {
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
  
  isSpeaking = false;
  hideVolumeIndicator();
  console.log('üîä All speech stopped');
}

function showVolumeIndicator() {
  volumeIndicator.classList.add('show');
  setTimeout(() => {
    volumeIndicator.classList.remove('show');
  }, 3000);
}

function hideVolumeIndicator() {
  volumeIndicator.classList.remove('show');
}

/* ================= CALL MODE SYSTEM ================= */
async function startCallMode() {
  if (isCallModeActive) {
    endCallMode();
    return;
  }

  if (!speechRecognition) {
    alert('Speech recognition is not supported in your browser.');
    return;
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop());
    
    isCallModeActive = true;
    continuousListening = true;
    isProcessingCall = false;
    callSession = activeChatId || crypto.randomUUID();
    
    isTextOnlyMode = false;
    isVoiceToTextMode = false;
    
    callModeOverlay.classList.add('active');
    callModeBtn.classList.add('call-mode');
    callStatus.textContent = 'üìû Call Connected';
    callTranscript.textContent = 'DEN.AI sedang mendengarkan';
    
    if (landing.style.display !== 'none') {
      landing.style.display = 'none';
      chat.style.display = 'flex';
      if (!activeChatId) {
        newChat();
      }
    }
    
    restartCallListening();
    
    console.log('üî• CALL MODE: Activated - Natural speech-to-speech ready!');
    
  } catch (error) {
    console.error('Failed to start call mode:', error);
    alert('Failed to access microphone. Please allow microphone access and try again.');
  }
}

function endCallMode() {
  isCallModeActive = false;
  continuousListening = false;
  isProcessingCall = false;
  
  if (speechRecognition && isListening) {
    speechRecognition.stop();
  }
  
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  callModeOverlay.classList.remove('active');
  callModeBtn.classList.remove('call-mode');
  showAudioVisualization(false);
  
  console.log('üìû CALL MODE: Ended');
}

function restartCallListening() {
  if (!isCallModeActive || !continuousListening || isProcessingCall) {
    return;
  }

  try {
    if (speechRecognition) {
      speechRecognition.start();
      console.log('[CALL] Restarting continuous listening...');
    }
  } catch (error) {
    console.error('[CALL] Failed to restart listening:', error);
    setTimeout(() => restartCallListening(), 2000);
  }
}

async function handleCallModeInput(transcript) {
  if (!transcript || isProcessingCall) {
    return;
  }

  isProcessingCall = true;
  callStatus.textContent = 'ü§ñ Processing...';
  callTranscript.textContent = `You: ${transcript}`;
  
  if (speechRecognition && isListening) {
    speechRecognition.stop();
  }
  
  await new Promise(resolve => setTimeout(resolve, 300));
  
  try {
    playProcessingFeedback();
    
    addMessage("user", transcript);
    
    await askBackend(transcript);
    
    setTimeout(() => {
      if (isCallModeActive && continuousListening) {
        isProcessingCall = false;
        callStatus.textContent = 'üé§ Listening...';
        callTranscript.textContent = 'Bicara lagi...';
        restartCallListening();
      }
    }, 2000);
    
  } catch (error) {
    console.error('[CALL] Error processing input:', error);
    stopProcessingFeedback();
    isProcessingCall = false;
    if (isCallModeActive) {
      restartCallListening();
    }
  }
}

function toggleMute() {
  const isMuted = muteBtn.classList.contains('active');
  
  if (isMuted) {
    muteBtn.classList.remove('active');
    muteBtn.textContent = 'üé§';
    continuousListening = true;
    if (isCallModeActive && !isProcessingCall) {
      restartCallListening();
    }
  } else {
    muteBtn.classList.add('active');
    muteBtn.textContent = 'üîá';
    continuousListening = false;
    if (speechRecognition && isListening) {
      speechRecognition.stop();
    }
  }
}

function showAudioVisualization(show) {
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  
  if (show) {
    bars.forEach((bar, index) => {
      bar.classList.add('active');
      bar.style.animationDelay = `${index * 0.1}s`;
    });
  } else {
    bars.forEach(bar => {
      bar.classList.remove('active');
    });
  }
}

/* ================= REGULAR SPEECH RECOGNITION ================= */
async function startSpeechRecognition(button, input) {
  if (!speechRecognition) {
    alert('Speech recognition is not supported in your browser.');
    return;
  }

  if (isListening) {
    console.log('[STT] Stopping current listening session');
    speechRecognition.stop();
    return;
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop());
    
  } catch (permissionError) {
    console.error('[STT] ‚ùå Microphone permission denied:', permissionError);
    alert('Microphone access is required for speech recognition.');
    return;
  }

  if (isSpeaking) {
    stopTextToSpeech();
  }

  currentSpeechButton = button;
  currentInput = input;
  
  isVoiceToTextMode = true; 
  isTextOnlyMode = false;
  
  speechRecognition.continuous = false;
  speechRecognition.interimResults = true;

  try {
    speechRecognition.start();
  } catch (error) {
    console.error('[STT] ‚ùå Failed to start speech recognition:', error);
  }
}

function updateSpeechUI(isActive) {
  if (!isCallModeActive) {
    document.querySelectorAll('.speech-btn').forEach(btn => {
      if (isActive && btn === currentSpeechButton) {
        btn.classList.add('listening');
      } else if (!isActive) {
        btn.classList.remove('listening');
      }
    });
  }
}

/* ================= USER ROLE & SESSION MANAGEMENT ================= */
async function getUserRole() {
  try {
    const response = await fetch('http://127.0.0.1:8000/user/role', {
      headers: { "Accept": "application/json" }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    userRole = data.role || "Employee";
    isHR = data.is_hr || false;
    
    updateUserInterface();
    
  } catch (error) {
    console.error('Failed to get user role:', error);
    userRole = 'Employee';
    isHR = false;
    updateUserInterface();
  }
}

function updateUserInterface() {
  if (isHR) {
    userBadge.classList.add("hr");
    userRoleText.textContent = "HR Access";
  } else {
    userBadge.classList.remove("hr");
    userRoleText.textContent = "Employee";
  }
  
  loadSessions();
}

/* ================= CHAT FUNCTIONS ================= */
function newChat() {
  activeChatId = crypto.randomUUID();
  conversationHistory = [];
  messages.innerHTML = "";
  landing.style.display = "none";
  chat.style.display = "flex";
  
  if (!isCallModeActive) {
    chatInput.focus();
  }
}

function startFromLanding() {
  const text = landingInput.value.trim();
  if (!text || isWaitingForResponse) return;
  
  isTextOnlyMode = true;
  isVoiceToTextMode = false;
  
  setInputState(true);
  newChat();
  addMessage("user", text);
  askBackend(text);
  landingInput.value = "";
  setInputState(false);
}

function addMessage(role, text, shouldSave = true) {
  const div = document.createElement("div");
  div.className = `msg ${role==="user"?"user-msg user":"bot"}`;
  
  const avatarText = role === "user" ? "YOU" : "AI";
  
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  
  if (role === "user") {
    bubble.textContent = text;
  } else {
    bubble.innerHTML = text;
  }
  
  div.innerHTML = `<div class="avatar">${avatarText}</div>`;
  div.appendChild(bubble);
  
  // Only show TTS controls for bot messages and when not in text-only mode
  if (role === "bot" && !isTextOnlyMode && !isCallModeActive) {
    const actions = document.createElement("div");
    actions.className = "message-actions";
    actions.innerHTML = `
      <button class="action-btn" onclick="speakMessage(this)" title="Read aloud">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M8.364 18.364L7 17l6-6-6-6 1.364-1.364L14.727 10l-6.363 6.364z"></path>
        </svg>
      </button>
      <button class="action-btn" onclick="stopTextToSpeech()" title="Stop speaking">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    `;
    div.appendChild(actions);
  }
  
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  
  if (shouldSave) {
    const textForHistory = role === "user" ? text : stripHtml(text);
    conversationHistory.push({
      role: role,
      message: textForHistory,
      timestamp: new Date().toISOString()
    });
  }
  
  return div;
}

function speakMessage(button) {
  const bubble = button.closest('.msg').querySelector('.bubble');
  if (bubble) {
    isTextOnlyMode = false;
    isVoiceToTextMode = false;
    
    const htmlText = bubble.innerHTML;
    speakText(htmlText);
  }
}

function stripHtml(html) {
  const tmp = document.createElement("div");
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || "";
}

function setInputState(disabled) {
  if (!isCallModeActive) {
    chatInput.disabled = disabled;
    sendButton.disabled = disabled;
    landingInput.disabled = disabled;
    
    document.querySelectorAll('.speech-btn').forEach(btn => {
      btn.disabled = disabled;
    });
    
    if (disabled) {
      sendButton.innerHTML = '<div class="loading-indicator"></div>';
    } else {
      sendButton.innerHTML = 'Send';
    }
  }
  
  isWaitingForResponse = disabled;
}

/* ================= BACKEND COMMUNICATION ================= */
async function askBackend(text) {
  if (isWaitingForResponse && !isCallModeActive) return;
  
  setInputState(true);

  // üî• ENHANCED UX: Show processing message immediately
  let processingMessage = null;
  if (!isCallModeActive) {
    processingMessage = showProcessingMessage();
  }

  console.log(`üîä Mode check: isTextOnlyMode=${isTextOnlyMode}, isVoiceToTextMode=${isVoiceToTextMode}, isCallModeActive=${isCallModeActive}`);
  
  if (!isTextOnlyMode && !isVoiceToTextMode) {
    console.log('üîä Playing processing feedback (normal mode)');
    playProcessingFeedback();
  } else {
    console.log('üîá Skipping processing feedback (text/voice-to-text mode)');
  }
  
  // üéØ SMART VISUALIZATION DETECTION
  const shouldTryVisualization = detectVisualizationQuery(text);
  
  if (shouldTryVisualization && userRole === "HR") {
    console.log('üìä Detected potential visualization query, using enhanced endpoint');
    try {
      return await askWithVisualization(text);
    } catch (error) {
      console.log('üìä Visualization failed, falling back to regular endpoint');
      // Continue with regular flow
    }
  }
  
  const payload = {
    question: text,
    session_id: activeChatId,
    user_role: userRole || "Employee"
  };

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 45000);

    const res = await fetch("http://127.0.0.1:8000/ask", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(payload),
      signal: controller.signal
    });

    clearTimeout(timeoutId);
    stopProcessingFeedback();

    // Remove processing message
    if (processingMessage && processingMessage.parentNode) {
      processingMessage.remove();
    }

    if (res.status === 429) {
      addMessage("bot", "‚è∞ <strong>Rate Limit Exceeded</strong><br><br>Too many requests. Please wait a moment.");
      return;
    }

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();
    
    let responseText = "";
    
    if (data.error) {
      responseText = `‚ùå <strong>Error</strong><br><br>${data.error}`;
    } else if (data.authorized === false) {
      responseText = `üîí <strong>Access Denied</strong><br><br>${data.answer}`;
    } else if (data.answer) {
      responseText = data.answer;
    } else {
      responseText = "‚ùì Received unexpected response format from server.";
    }
    
    const messageElement = addMessage("bot", responseText);
    
    // üî• CONDITIONAL AUTO-SPEAK
    setTimeout(() => {
      if (isCallModeActive) {
        console.log('üîä Call mode: Auto-speaking response');
        speakText(responseText, {
          language: 'id',
          voice: 'indonesian'
        });
      }
      else if (isTextOnlyMode) {
        console.log('üîá Text-only mode: No auto-speech');
      }
      else if (isVoiceToTextMode) {
        console.log('üîá Voice-to-text mode: No auto-speech');
        isVoiceToTextMode = false;
      }
      else {
        console.log('üîä Normal mode: Auto-speaking response');
        speakText(responseText, {
          language: 'id',
          voice: 'indonesian'
        });
      }
    }, isCallModeActive ? 200 : 800);
    
  } catch (err) {
    stopProcessingFeedback();
    if (processingMessage && processingMessage.parentNode) {
      processingMessage.remove();
    }
    
    let errorMessage = "‚ùå Failed to connect to server.";
    
    if (err.name === 'AbortError') {
      errorMessage = "‚è∞ Request timed out. Please try again.";
    }
    
    addMessage("bot", errorMessage);
    
    if (isCallModeActive) {
      setTimeout(() => {
        speakText(stripHtml(errorMessage));
      }, 500);
    }
    
  } finally {
    setInputState(false);
    if (!isCallModeActive && chatInput) {
      chatInput.focus();
    }
    
    try {
      await loadSessions();
    } catch (sessionError) {
      console.error("Session update failed:", sessionError);
    }
  }
}

function detectVisualizationQuery(text) {
  /**
   * Smart detection of queries that might benefit from visualization
   */
  const vizKeywords = [
    'distribusi', 'distribution', 'breakdown', 'sebaran',
    'berapa per', 'jumlah per', 'count per',
    'perbandingan', 'compare', 'vs',
    'trend', 'perkembangan', 'over time',
    'chart', 'grafik', 'diagram',
    'analisis', 'analysis', 'analytics'
  ];
  
  const textLower = text.toLowerCase();
  
  // Check for visualization keywords
  const hasVizKeyword = vizKeywords.some(keyword => textLower.includes(keyword));
  
  // Check for HR data patterns
  const hasHRPattern = textLower.includes('karyawan') || textLower.includes('employee') || 
                      textLower.includes('band') || textLower.includes('pendidikan') ||
                      textLower.includes('lokasi') || textLower.includes('status');
  
  return hasVizKeyword && hasHRPattern;
}

/* ================= SESSION MANAGEMENT ================= */
async function togglePinSession(sessionId, event) {
  event.stopPropagation();
  
  try {
    const response = await fetch(`http://127.0.0.1:8000/sessions/${sessionId}/pin`, {
      method: 'POST',
      headers: { 'Accept': 'application/json' }
    });
    
    if (response.ok) {
      await loadSessions();
    }
  } catch (error) {
    console.error('Failed to pin session:', error);
  }
}

async function deleteSession(sessionId, event) {
  event.stopPropagation();
  
  const confirmed = confirm('Are you sure you want to delete this conversation?');
  if (!confirmed) return;
  
  try {
    const response = await fetch(`http://127.0.0.1:8000/sessions/${sessionId}`, {
      method: 'DELETE',
      headers: { 'Accept': 'application/json' }
    });
    
    if (response.ok) {
      if (sessionId === activeChatId) {
        activeChatId = null;
        conversationHistory = [];
        messages.innerHTML = "";
        landing.style.display = "flex";
        chat.style.display = "none";
      }
      
      await loadSessions();
    }
  } catch (error) {
    console.error('Failed to delete session:', error);
    alert('Failed to delete conversation. Please try again.');
  }
}

async function loadSessions() {
  try {
    const res = await fetch("http://127.0.0.1:8000/sessions", {
      headers: { "Accept": "application/json" }
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    
    const sessions = await res.json();
    const list = document.getElementById("sessionList");
    list.innerHTML = "";
    
    let filteredSessions = sessions;
    
    if (!isHR) {
      filteredSessions = sessions.filter(s => {
        const title = (s.title || '').toLowerCase();
        const hrKeywords = [
          'karyawan', 'band', 'employee', 'gaji', 
          'kontrak', 'salary', 'upah', 'pegawai', 
          'staff', 'sdm', 'personalia', 'jumlah'
        ];
        const isHRConversation = hrKeywords.some(keyword => title.includes(keyword));
        return !isHRConversation;
      });
    }
    
    // Separate pinned and recent sessions
    const pinnedSessions = filteredSessions.filter(s => s.pinned);
    const recentSessions = filteredSessions.filter(s => !s.pinned);
    
    // Create Starred section if there are pinned sessions
    if (pinnedSessions.length > 0) {
      const starredSection = document.createElement("div");
      starredSection.className = "session-section";
      starredSection.innerHTML = `
        <div class="section-header">Starred</div>
        <div class="session-list starred-list"></div>
      `;
      list.appendChild(starredSection);
      
      const starredList = starredSection.querySelector('.starred-list');
      pinnedSessions.forEach((s) => {
        const div = createSessionItem(s);
        starredList.appendChild(div);
      });
    }
    
    // Create Recents section
    if (recentSessions.length > 0) {
      const recentsSection = document.createElement("div");
      recentsSection.className = "session-section";
      recentsSection.innerHTML = `
        <div class="section-header">Recents</div>
        <div class="session-list recents-list"></div>
      `;
      list.appendChild(recentsSection);
      
      const recentsList = recentsSection.querySelector('.recents-list');
      recentSessions.forEach((s) => {
        const div = createSessionItem(s);
        recentsList.appendChild(div);
      });
    }
    
  } catch (err) {
    console.error("Failed to load sessions:", err);
  }
}

function createSessionItem(s) {
  const div = document.createElement("div");
  div.className = "session-item";
  if (s.session_id === activeChatId) div.classList.add("active");

  const isPinned = s.pinned || false;
  
  div.innerHTML = `
    <span class="title">
      ${s.title || 'Untitled Conversation'}
    </span>
    <div class="session-actions">
      <button class="session-action-btn pin-btn ${isPinned ? 'active' : ''}" 
              onclick="togglePinSession('${s.session_id}', event)" 
              title="${isPinned ? 'Unstar' : 'Star'}">
        <svg fill="${isPinned ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path>
        </svg>
      </button>
      <button class="session-action-btn delete-btn" 
              onclick="deleteSession('${s.session_id}', event)" 
              title="Delete">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
      </button>
    </div>
  `;

  div.onclick = (e) => {
    if (e.target.closest('.session-actions')) return;
    loadSession(s.session_id);
  };
  
  return div;
}

async function loadSession(sessionId) {
  if (isWaitingForResponse) return;
  
  try {
    activeChatId = sessionId;
    conversationHistory = [];

    messages.innerHTML = "";
    landing.style.display = "none";
    chat.style.display = "flex";

    const res = await fetch(`http://127.0.0.1:8000/history/${sessionId}`, {
      headers: { "Accept": "application/json" }
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    
    const history = await res.json();

    history.forEach(m => {
      addMessage(m.role, m.message, false);
      
      const textForHistory = m.role === "user" ? m.message : stripHtml(m.message);
      conversationHistory.push({
        role: m.role,
        message: textForHistory,
        timestamp: m.timestamp || new Date().toISOString()
      });
    });

    await loadSessions();
    if (!isCallModeActive) {
      chatInput.focus();
    }
    
  } catch (err) {
    console.error("Failed to load session:", err);
    addMessage("bot", "‚ùå Failed to load conversation.");
  }
}

function sendMessage() {
  const text = chatInput.value.trim();
  if (!text || isWaitingForResponse) return;

  isTextOnlyMode = true;
  isVoiceToTextMode = false;

  addMessage("user", text);
  askBackend(text);
  chatInput.value = "";
}

/* ================= EVENT LISTENERS ================= */

// Call mode controls
callModeBtn.addEventListener("click", startCallMode);
endCallBtn.addEventListener("click", endCallMode);
muteBtn.addEventListener("click", toggleMute);

// Regular input events
chatInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !isWaitingForResponse && !e.shiftKey && !isCallModeActive) {
    e.preventDefault();
    sendMessage();
  }
});

landingInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !isWaitingForResponse && !e.shiftKey && !isCallModeActive) {
    e.preventDefault();
    startFromLanding();
  }
});

// Speech buttons
landingSpeechBtn.addEventListener("click", () => {
  if (!isCallModeActive) {
    startSpeechRecognition(landingSpeechBtn, landingInput);
  }
});

chatSpeechBtn.addEventListener("click", () => {
  if (!isCallModeActive) {
    startSpeechRecognition(chatSpeechBtn, chatInput);
  }
});

// Stop typing when speaking
chatInput.addEventListener("input", () => {
  if (isListening && !isCallModeActive) {
    speechRecognition.stop();
  }
});

landingInput.addEventListener("input", () => {
  if (isListening && !isCallModeActive) {
    speechRecognition.stop();
  }
});

// Global keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && isCallModeActive) {
    endCallMode();
  }
  
  if ((e.ctrlKey || e.metaKey) && e.key === '/') {
    e.preventDefault();
    if (isCallModeActive) {
      endCallMode();
    } else {
      startCallMode();
    }
  }
});

/* ================= INITIALIZATION ================= */
document.addEventListener("DOMContentLoaded", async () => {
  const speechAvailable = initializeSpeechRecognition();
  await getUserRole();
  
  if (!isCallModeActive) {
    landingInput.focus();
  }
  
  console.log("üéôÔ∏è DEN¬∑AI Professional Assistant with LLM Visualization Ready!");
  console.log(`üë§ User: ${userRole} | üé§ Speech: ${speechAvailable ? 'ENABLED' : 'DISABLED'}`);
  console.log("üìä VISUALIZATION: LLM-generated charts, zero-hardcoding");
  console.log("üìû CALL MODE: Press phone button or Ctrl+/ for natural conversation!");
  console.log("üéØ MODES: Text ‚Üí No audio | Voice ‚Üí Text only | Call ‚Üí Full audio");
  console.log("üìà CHARTS: Bar, Pie, Line, Doughnut with corporate styling");
});
</script>

</body>
</html>